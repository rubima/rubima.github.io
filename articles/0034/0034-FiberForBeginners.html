<!DOCTYPE html>
<html>
  



  <head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-41117431-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-41117431-1');
  </script>
  <script src="../../js/gtag.js"></script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Fiber と Proc ―― 手続きを抽象化する二つの機能</title>
  <meta name="description" content="">

  <script src="../../js/jquery.min.js"></script>
  <script src="../../js/bootstrap.min.js"></script>
  <link href="../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../../css/theme.css" rel="stylesheet" type="text/css">
  <link href="../../css/syntax.css" rel="stylesheet" type="text/css">
  <link href="../../css/sharebutton.css" rel="stylesheet" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="https://magazine.rubyist.net/articles/0034/0034-FiberForBeginners.html">
  <link rel="alternate" type="application/rss+xml" title="Rubyist Magazine" href="https://magazine.rubyist.net/feed.xml">
  <link rel="shortcut icon" href="../../images/favicon.ico">
</head>

  <body>
    <div class="container-fluid">
        <div class="row full">
            <div class="col-md-2 hidden-xs sidebar">
                <h4>

</h4>

<h4>バックナンバー</h4>
<ul>
    <li><a href="../../articles/backnumber/backnumber.html">記事単位</a></li>
    <hr>
    
        <li><a href="../../articles/kaigi_on_rails/index.html">Kaigi on Rails 特集号</a></li>
    
        <li><a href="../../articles/prerubykaigi2020/preRubyKaigi2020-index.html">RubyKaigi Takeout 2020 特集号</a></li>
    
        <li><a href="../../articles/0061/0061-index.html">0061号(2020-02)</a></li>
    
        <li><a href="../../articles/0060/0060-index.html">0060号(2019-08)</a></li>
    
        <li><a href="../../articles/prerubykaigi2019/preRubyKaigi2019-index.html">RubyKaigi 2019 直前特集号</a></li>
    
        <li><a href="../../articles/0059/0059-index.html">0059号(2019-01)</a></li>
    
        <li><a href="../../articles/0058/0058-index.html">0058号(2018-08)</a></li>
    
        <li><a href="../../articles/prerubykaigi2018/preRubyKaigi2018-index.html">RubyKaigi 2018 直前特集号</a></li>
    
        <li><a href="../../articles/0057/0057-index.html">0057号(2018-02)</a></li>
    
        <li><a href="../../articles/prerubykaigi2017/preRubyKaigi2017-index.html">RubyKaigi 2017 直前特集号</a></li>
    
        <li><a href="../../articles/0056/0056-index.html">0056号(2017-08)</a></li>
    
        <li><a href="../../articles/0055/0055-index.html">0055号(2017-03)</a></li>
    
        <li><a href="../../articles/0054/0054-index.html">0054号(2016-08)</a></li>
    
        <li><a href="../../articles/pretokyorubykaigi11/preTokyoRubyKaigi11-index.html">東京 Ruby 会議 11 直前特集号</a></li>
    
        <li><a href="../../articles/0053/0053-index.html">0053号(2016-04)</a></li>
    
        <li><a href="../../articles/0052/0052-index.html">0052号(2015-12)</a></li>
    
        <li><a href="../../articles/0051/0051-index.html">0051号(2015-09)</a></li>
    
        <li><a href="../../articles/0050/0050-index.html">0050号(2015-05)</a></li>
    
        <li><a href="../../articles/0049/0049-index.html">0049号(2014-12)</a></li>
    
        <li><a href="../../articles/0048/0048-index.html">0048号(2014-09)</a></li>
    
        <li><a href="../../articles/0047/0047-index.html">0047号(2014-06)</a></li>
    
        <li><a href="../../articles/0046/0046-index.html">0046号(2014-04)</a></li>
    
        <li><a href="../../articles/0045/0045-index.html">0045号(2013-12)</a></li>
    
        <li><a href="../../articles/0044/0044-index.html">0044号(2013-09)</a></li>
    
        <li><a href="../../articles/0043/0043-index.html">0043号(2013-07)</a></li>
    
        <li><a href="../../articles/0042/0042-index.html">0042号(2013-05)</a></li>
    
        <li><a href="../../articles/ruby200specialen/Ruby200SpecialEn-index.html">2.0.0 Special (EN)</a></li>
    
        <li><a href="../../articles/0041/0041-index.html">0041号(2013-02)</a></li>
    
        <li><a href="../../articles/0040/0040-index.html">0040号(2012-11)</a></li>
    
        <li><a href="../../articles/0039/0039-index.html">0039号(2012-09)</a></li>
    
        <li><a href="../../articles/rubykaja/kaja.html">RubyKaja のご紹介</a></li>
    
        <li><a href="../../articles/0038/0038-index.html">0038号(2012-05)</a></li>
    
        <li><a href="../../articles/0037/0037-index.html">0037号(2012-02)</a></li>
    
        <li><a href="../../articles/0036/0036-index.html">0036号(2011-11)</a></li>
    
        <li><a href="../../articles/0035/0035-index.html">0035号(2011-09)</a></li>
    
        <li><a href="../../articles/prerubykaigi2011/preRubyKaigi2011-index.html">RubyKaigi2011直前特集号</a></li>
    
        <li><a href="../../articles/0034/0034-index.html">0034号(2011-06)</a></li>
    
        <li><a href="../../articles/0033/0033-index.html">0033号(2011-04)</a></li>
    
        <li><a href="../../articles/0032/0032-index.html">0032号(2011-01)</a></li>
    
        <li><a href="../../articles/0031/0031-index.html">0031号(2010-10)</a></li>
    
        <li><a href="../../articles/prerubykaigi2010/preRubyKaigi2010-index.html">RubyKaigi2010直前特集号</a></li>
    
        <li><a href="../../articles/0030/0030-index.html">0030号(2010-06)</a></li>
    
        <li><a href="../../articles/0029/0029-index.html">0029号(2010-03)</a></li>
    
        <li><a href="../../articles/0028/0028-index.html">0028号(2009-12)</a></li>
    
        <li><a href="../../articles/0027/0027-index.html">0027号(2009-09)</a></li>
    
        <li><a href="../../articles/0026/0026-index.html">0026号(2009-06)</a></li>
    
        <li><a href="../../articles/0025/0025-index.html">0025号(2009-02)</a></li>
    
        <li><a href="../../articles/0024/0024-index.html">0024号(2008-10)</a></li>
    
        <li><a href="../../articles/0023/0023-index.html">0023号(2008-03)</a></li>
    
        <li><a href="../../articles/0022/0022-index.html">0022号(2007-12)</a></li>
    
        <li><a href="../../articles/0021/0021-index.html">0021号(2007-09)</a></li>
    
        <li><a href="../../articles/0020/0020-index.html">0020号(2007-08)</a></li>
    
        <li><a href="../../articles/0019/0019-index.html">0019号(2007-05)</a></li>
    
        <li><a href="../../articles/0018/0018-index.html">0018号(2007-02)</a></li>
    
        <li><a href="../../articles/0017/0017-index.html">0017号(2006-11)</a></li>
    
        <li><a href="../../articles/0016/0016-index.html">0016号(2006-09)</a></li>
    
        <li><a href="../../articles/0015/0015-index.html">0015号(2006-07)</a></li>
    
        <li><a href="../../articles/rubykaigi2006/RubyKaigi2006-index.html">日本 Ruby カンファレンス 2006 特別号</a></li>
    
        <li><a href="../../articles/0014/0014-index.html">0014号(2006-05)</a></li>
    
        <li><a href="../../articles/0013/0013-index.html">0013号(2006-02)</a></li>
    
        <li><a href="../../articles/0012/0012-index.html">0012号(2005-12)</a></li>
    
        <li><a href="../../articles/0011/0011-index.html">0011号(2005-11)</a></li>
    
        <li><a href="../../articles/0010/0010-index.html">0010号(2005-10)</a></li>
    
        <li><a href="../../articles/0009/0009-index.html">0009号(2005-09)</a></li>
    
        <li><a href="../../articles/0008/0008-index.html">0008号(2005-07)</a></li>
    
        <li><a href="../../articles/0007/0007-index.html">0007号(2005-06)</a></li>
    
        <li><a href="../../articles/0006/0006-index.html">0006号(2005-05)</a></li>
    
        <li><a href="../../articles/0005/0005-index.html">0005号(2005-02)</a></li>
    
        <li><a href="../../articles/0004/0004-index.html">0004号(2004-12)</a></li>
    
        <li><a href="../../articles/0003/0003-index.html">0003号(2004-11)</a></li>
    
        <li><a href="../../articles/0002/0002-index.html">0002号(2004-10)</a></li>
    
        <li><a href="../../articles/0001/0001-index.html">0001号(2004-09)</a></li>
    
</ul>
<p class="rss-subscribe"><a href="/feed.xml">RSS</a></p>

            </div>
            <div class="col-md-10 main">
                <div class="row">
                    <div class="col-md-12">
                        <img src="../../images/rubima_logo_l.png">
                        <h1>Fiber と Proc ―― 手続きを抽象化する二つの機能</h1>
                        <div class="social-buttons">
                            <div class='sns'>            
    <ul class="clearfix">
       <li class="twitter"><a href="https://twitter.com/share?text=Fiber と Proc ―― 手続きを抽象化する二つの機能&amp;url=https://magazine.rubyist.net/articles/0034/0034-FiberForBeginners.html" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa fa-twitter"></i></a></li>
       <li class="facebook"><a href="https://www.facebook.com/sharer.php?u=https://magazine.rubyist.net/articles/0034/0034-FiberForBeginners.html&amp;t=Fiber と Proc ―― 手続きを抽象化する二つの機能" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa fa-facebook"></i></a></li>
       <li class="hatebu"><a href="http://b.hatena.ne.jp/add?mode=confirm&amp;url=https://magazine.rubyist.net/articles/0034/0034-FiberForBeginners.html&amp;Fiber と Proc ―― 手続きを抽象化する二つの機能" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa">B!</i></a></li>
    </ul>
</div>
                        </div>
                        <div class="post_info">
                            

  <span class="created_on">初稿：2011-06-12</span>



                        </div>
                        
<h2 id="fiber-と-proc--手続きを抽象化する二つの機能">Fiber と Proc ―― 手続きを抽象化する二つの機能</h2>

<h3 id="はじめに">はじめに</h3>

<p>最近、複数のプログラミング言語を学ぶことが重要だと良く耳にするようになりました。</p>

<p>たとえば書籍「<a href="http://www.oreilly.co.jp/books/9784873114798/">プログラマが知るべき 97 のこと</a>」の「43. プログラミング言語は複数習得すべき」において、<a href="http://www.russel.org.uk/">Russel Winder 氏</a>は次のように書き、複数のプログラミング言語 (それも異なるパラダイムに属する言語) を学ぶことを勧めています。</p>

<blockquote>
  <p>プログラミング言語のパラダイムは大きく、手続き型、オブジェクト指向型、
関数型、論理型、データフロー型などに分類することができます。
2番目に学ぶ言語のパラダイムが最初の言語と同じであれば習得は楽ですが、
パラダイムが違っていると、習得は困難になります。</p>

  <p>しかし第二の言語には、是非とも、最初の言語とはパラダイムの違う言語を
選ぶべきです。それはなぜかというと、パラダイムの違う言語を学ぶと、
アルゴリズム、イディオム、パターンの実装について嫌でも考えるように
なるからです。同様のアルゴリズムを実装するにしても、色々なやりかたが
あり得ることに気づきます。この体験が、プログラマの技術を大きく向上させます。</p>
</blockquote>

<p>そして 2007 年に行われた「<a href="http://jp.rubyist.net/RubyKaigi2007/">日本 Ruby 会議 2007</a>」のキーノートスピーチ「<a href="http://jp.rubyist.net/RubyKaigi2007/Log0610-S5.html">The Island of Ruby (島国としてのRuby) </a>」にて、<a href="http://pragdave.pragprog.com/">Dave Thomas 氏</a>は次のように述べました。</p>

<blockquote>
  <p>Rubyはいくつものパラダイムを許容する言語だ。
オブジェクト指向的にだけではなくて、手続き的にも書けるし、
プロトタイプベースのようにも書ける。
試してみると面白いよ。
関数型のようにだって書ける。副作用が無いわけじゃないけれど。
こういうことができるといろいろと良いことがある。</p>
</blockquote>

<p>Ruby では異なるパラダイムのプログラミング言語を学ぶことで得られた新しい知見を生かすことができます。今回の記事では Ruby の Fiber と Proc という「手続きを抽象化する二つの機能」を「手続き型言語」と「関数型言語」という視点で解説し、その考え方の違いを見ていきたいと思います。</p>

<h3 id="手続き型言語と関数型言語">手続き型言語と関数型言語</h3>

<p>先ほども出てきた通り、Ruby は「オブジェクト指向言語」だと言われていますが、「手続き型言語」や「関数型言語」のようにプログラムを書くこともできます。Fiber と Proc の説明に入る前に、手続き型言語と関数型言語はどのようなものなのかを見てみることにしましょう。</p>

<p>「手続き型言語」とは、プログラムを書いた順番通りに実行していくプログラム言語のことです。たとえば次のような「結婚披露宴の次第」は手続き型言語と考えることが出来ます。</p>

<ol>
  <li>招待客の入場</li>
  <li>新郎新婦の入場</li>
  <li>主賓の祝辞</li>
  <li>乾杯</li>
  <li>食事・歓談</li>
  <li>ケーキ入刀</li>
  <li>・・・</li>
</ol>

<p>結婚披露宴の当日は、上記の次第に書かれた通りに実行されます (ハプニングがあるかもしれませんが‥‥) 。</p>

<p>「関数型言語」とは、プログラムを関数の集合と考えるプログラム言語のことです。プログラムは関数に引数を与え、その戻り値をまた次の関数の引数として与える‥‥という形で実行されます。</p>

<p>たとえば自動販売機 (vendingMachine) を関数で表すとしたら、「お金をいくら入れたか (Money)」「どのボタンを押したか (Switch)」を引数として取り、「おつり (Money)」「商品 (Product)」を返す関数として定義することができます。</p>

<p>例として関数型言語のひとつである Haskell というプログラミング言語では、次のようにして関数の引数と戻り値を定義できます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">vendingMachine :: (Money, Switch) -&gt; (Money, Product)</code></pre></figure>

<p>上記の説明を聞いても、何だかよく分かりませんよね。では実際に「手続き型言語」と「関数型言語」のそれぞれで、どのような発想でプログラムが書かれていくのか、Ruby のコードで実際に実装しながら見ていきましょう。</p>

<h4 id="フィボナッチ数列">フィボナッチ数列</h4>

<p>突然ですが、ここでクイズです。</p>

<p>フィボナッチ数列 (0, 1, 1, 2, 3, 5, 8, …) とは、次のような数列です。</p>

<ul>
  <li>fib(0) は「0」</li>
  <li>fib(1) は「1」</li>
  <li>2 以上の整数 n に対して、fib(n) は「fib(n - 1) + fib(n - 2)」</li>
</ul>

<p>つまり、fib(2) 以降は「ひとつ前の数とふたつ前の数を足したもの」になります。</p>

<ul>
  <li>fib(2) は「0 + 1」なので「1」</li>
  <li>fib(3) は「1 + 1」なので「2」</li>
  <li>fib(4) は「1 + 2」なので「3」</li>
  <li>fib(5) は「2 + 3」なので「5」</li>
  <li>fib(6) は「3 + 5」なので「8」</li>
  <li>‥‥</li>
</ul>

<p>では問題です。</p>

<blockquote>
  <p>Q. 任意の n 番目のフィボナッチ数列の値を求めるメソッド fib(n) を書いてください。</p>
</blockquote>

<p>つまり、次のようなファイル fib.rb を書いて、</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="c1"># ここを実装する</span>
<span class="k">end</span>

</code></pre></div></div>

<p>次のようなテストケース test_fib.rb を満たすような fib メソッド実装してください。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'fib'</span>
<span class="nb">require</span> <span class="s1">'test/unit'</span>

<span class="k">class</span> <span class="nc">TestFib</span> <span class="o">&lt;</span> <span class="no">Test</span><span class="o">::</span><span class="no">Unit</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="k">def</span> <span class="nf">test_fib</span>
    <span class="n">assert_equal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fib</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">assert_equal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fib</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">assert_equal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fib</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">assert_equal</span><span class="p">(</span><span class="mi">55</span><span class="p">,</span> <span class="n">fib</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<p>テストが成功すると、次のような実行結果になるはずです。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ ruby test_fib.rb
Loaded suite test_fib
Started
.
Finished in 0.000377 seconds.

1 tests, 4 assertions, 0 failures, 0 errors
$</code></pre></figure>

<p>では、この問題を「手続き型言語の発想」と「関数型言語の発想」で実装してみましょう。</p>

<h5 id="手続き型言語の発想">手続き型言語の発想</h5>

<p>ひとつ前の数とふたつ前の数を足した結果を求めると次の値が分かるから、ふたつ前までの数を覚えながら、次々に足していけばいいんじゃないかな？</p>

<p>ええと、じゃあまず 0 番目と 1 番目で「ひとつ前の数 (b)」と「ふたつ前の数 (a)」を変数に代入して初期化しよう。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>

</code></pre></div></div>

<p>次に、ひとつ前の数 (b) とふたつ前の数 (a) を足した結果を求めると、もうひとつ先の値が求められるね。なので「a + b」を新しい「b」に代入すればいいかな。そうそう、さらに先を求めるときに「ひとつ前の数」も覚えておく必要があるから、古い「b」は「a」に代入して保存しておこう。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

</code></pre></div></div>

<p>あとはこれを n 回繰り返せばいいよね。カウンタ (i) を用意して、ループごとにカウントアップして n より大きくなるまで繰り返せばいいかな。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">end</span>

</code></pre></div></div>

<p>最後に結果 a を返せば完成だね。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>
  <span class="n">a</span>
<span class="k">end</span>

</code></pre></div></div>

<h5 id="関数型言語の発想">関数型言語の発想</h5>

<ul>
  <li>fib(0) は「0」</li>
  <li>fib(1) は「1」</li>
  <li>2 以上の整数 n に対して、fib(n) は「fib(n - 1) + fib(n - 2)」</li>
</ul>

<p>って定義が書かれているんだから、そのまま定義を書き出してみればいいんじゃないかな。</p>

<p>n が 0 のとき、1 のとき、2 以上のときで場合分けしよう。場合分けは case を使えばいいよね。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span>
<span class="k">when</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span>
<span class="k">when</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span>
<span class="k">when</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">then</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">end</span>

</code></pre></div></div>

<p>あとはこれをメソッドとして定義してあげればとりあえず動く<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>ね。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">case</span>
  <span class="k">when</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span>
  <span class="k">when</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span>
  <span class="k">when</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">then</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<p>さて、手続き型言語と関数型言語とで、発想の違いを感じていただけたでしょうか？</p>

<p>手続き型言語の発想だと、プログラマはコンピュータが逐一どのように実行していくかを考えながらソースコードを書いていくことになります。今回の場合だと
「ループ」とか「カウンタ」とかが必要だ、というのは人間が判断してプログラムを書いていることになります。</p>

<p>それに比べて関数型言語の発想だと「定義を書いたからあとはコンピュータ頑張ってね」という発想であるのが分かると思います。計算の際にループしようとかカウンタがどうとかは全く考えません。</p>

<h4 id="fizzbuzz">FizzBuzz</h4>

<p>もうひとつ問題です。</p>

<blockquote>
  <p>Q. 1 から 100 までの数をプリントするプログラムを書け。ただし 3 の倍数のときは数の代わりに｢Fizz｣と、5 の倍数のときは｢Buzz｣とプリントし、3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントすること。</p>
</blockquote>

<p>この問題は｢<a href="http://www.aoky.net/articles/jeff_atwood/why_cant_programmers_program.htm">Fizz-Buzz問題</a>｣という有名な問題で、一時期話題になったので知っている方も多いと思います。</p>

<p>では、この問題も「手続き型言語の発想」と「関数型言語の発想」それぞれで実装してみましょう。</p>

<h4 id="手続き型言語の発想-1">手続き型言語の発想</h4>

<p>1 から 100 までの数をプリントするんだから、ループしてプリントすればよさそうだよね。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span>
  <span class="nb">puts</span> <span class="n">i</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">end</span>

</code></pre></div></div>

<p>3 の倍数のときは｢Fizz｣、5 の倍数のときは｢Buzz｣、3 と 5 両方の倍数の場合には｢FizzBuzz｣とプリントするのだから、「puts i」のところを if 文で条件分岐すればいいかな？　15 の倍数 (つまり 3 と 5 の倍数)、5 の倍数、3 の倍数それぞれで分岐すればいいよね。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span>
  <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">15</span> <span class="o">==</span> <span class="mi">0</span> 
    <span class="nb">puts</span> <span class="s1">'FizzBuzz'</span>
  <span class="k">elsif</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="nb">puts</span> <span class="s1">'Buzz'</span>
  <span class="k">elsif</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="nb">puts</span> <span class="s1">'Fizz'</span>
  <span class="k">else</span>
    <span class="nb">puts</span> <span class="n">i</span>
  <span class="k">end</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">end</span>

</code></pre></div></div>

<h5 id="関数型言語の発想-1">関数型言語の発想</h5>

<p>1 から 100 まで出力せよ、と言っているので、Range を Array に変換して出力すればいいよね。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">).</span><span class="nf">to_a</span>
</code></pre></div></div>

<p>3 の倍数のときは Fizz、5 の倍数のときは Buzz、3 と 5 の倍数のときは FizzBuzz を出力するのだから、変換ルールの関数を書いて map すればいいよね。変換ルールの関数は、15 の倍数 (つまり 3 と 5 の倍数)、5 の倍数、3 の倍数それぞれで場合分けすればいいけど、あとで考えよう。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">).</span><span class="nf">to_a</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="c1"># 3と5の倍数のときは FizzBuzz、</span>
  <span class="c1"># 5の倍数のときは Buzz、</span>
  <span class="c1"># xが3の倍数のときは Fizz に変換する関数</span>
<span class="p">}</span>
</code></pre></div></div>

<p>関数の中身は「複数の場合の場合分け」だから、case を使えばいいよね。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">).</span><span class="nf">to_a</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="k">case</span>
  <span class="k">when</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">15</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="s1">'FizzBuzz'</span>
  <span class="k">when</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="s1">'Buzz'</span>
  <span class="k">when</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="s1">'Fizz'</span>
  <span class="k">else</span> <span class="n">x</span>
  <span class="k">end</span>
<span class="p">}</span>
</code></pre></div></div>

<p>いかがでしたか。</p>

<p>先ほど同様、手続き型言語の発想は「プログラムは順番に実行されていくもの」なので、「ループしながら条件を変えつつ出力していく」というものですね。それに比較して関数型言語だと「ある構造を持ったデータ (ここでは 1 から 100 までの整数) に対して、変換ルール (関数) をそれぞれに適用する (map メソッド) 」という発想になり、「ループ」という発想が全くないことが分かります。</p>

<h3 id="fiber-と-proc">Fiber と Proc</h3>

<p>だいぶ前置きが長くなってしまいましたが、ようやくここからが本題の Fiber と Proc の解説となります。</p>

<p>Fiber は Ruby 1.9 で新しく導入されたクラスで、「これから起こること」を抽象化したものです。と言っても何のことか分からないと思いますので、実際にコードを書いてみることにしましょう。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="c1"># 処理</span>
<span class="k">end</span>

</code></pre></div></div>

<p>と書くと、「処理」の部分を「これから起こること」としてオブジェクト (Fiber クラスのインスタンス) を生成します。そしてその「処理」を実行したい場合、Fiber#resume メソッドを使います。また実際にコードを書いてみましょう。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fi</span> <span class="o">=</span> <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="c1"># 処理</span>
<span class="k">end</span> <span class="c1">#=&gt; 「処理」が Fiber クラスのインスタンスとして抽象化され、変数 fi に代入される</span>

<span class="n">fi</span><span class="p">.</span><span class="nf">resume</span> <span class="c1">#=&gt; 処理が実行される</span>

</code></pre></div></div>

<p>Proc も「これから起こること」をオブジェクト (Proc クラスのインスタンス) として抽象化したものです。たとえば、</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="c1"># 処理</span>
<span class="k">end</span>

</code></pre></div></div>

<p>と書くことで、先ほどの Fiber と同様、「処理」の部分を「これから起こること」としてオブジェクト化することができます。Proc の場合は、「処理」を実行したい場合、Proc#call メソッドを使います。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pr</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="c1"># 処理</span>
<span class="k">end</span> <span class="c1">#=&gt; 「処理」が Proc クラスのインスタンスとして抽象化され、変数 pr に代入される</span>

<span class="n">pr</span><span class="p">.</span><span class="nf">call</span> <span class="c1">#=&gt; 処理が実行される</span>

</code></pre></div></div>

<p>こうして見ると、どちらも「手続き (これから起こること) 」を抽象化するという点で同じようなもののように見えるかもしれません。ところが、Fiber と Proc では決定的に違うことがあります。Fiber で抽象化した「処理」は「処理」の中で Fiber.yield が呼ばれたタイミングで処理が終了し、再度呼び出した場合は Fiber.yield の呼び出しの続きから「処理」が再開されるのに対して、Proc で抽象化した「処理」は何度呼び出してもその「処理」の最初から実行されます。</p>

<p>これも言葉で聞いても何のことか分かりづらいと思いますので、実際のコードを見て Fiber と Proc がどのような挙動をするのかを見てみましょう。まずは Fiber の例です。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fi</span> <span class="o">=</span> <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">first</span><span class="o">|</span>
  <span class="n">second</span> <span class="o">=</span> <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">first</span><span class="si">}</span><span class="s2">!"</span><span class="p">)</span>
  <span class="s2">"</span><span class="si">#{</span><span class="n">first</span><span class="si">}</span><span class="s2">, </span><span class="si">#{</span><span class="n">second</span><span class="si">}</span><span class="s2">!"</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">fi</span><span class="p">.</span><span class="nf">resume</span><span class="p">(</span><span class="s1">'Hello'</span><span class="p">)</span> <span class="c1">#=&gt; "Hello!" と出力</span>
<span class="nb">puts</span> <span class="n">fi</span><span class="p">.</span><span class="nf">resume</span><span class="p">(</span><span class="s1">'World'</span><span class="p">)</span> <span class="c1">#=&gt; "Hello, World!" と出力</span>

</code></pre></div></div>

<p>変数 fi には、Fiber.new により do から end までの処理を抽象化した Fiber オブジェクトが代入されます。そして最初に文字列 ‘Hello’ を引数にその Fiber オブジェクトのインスタンスメソッド resume を呼び出すと、ブロックの引数 first に ‘Hello’ が代入され、ブロックの実行が開始します。</p>

<p>そして Fiber.yield が実行されたタイミングで resume メソッドの呼び出し元に処理が戻り、戻り値は Fiber.yield の引数 “#{first}!” すなわち “Hello!” になります。</p>

<p>次に文字列 ‘World’ を引数にまた resume メソッドを呼び出すと、次は先ほどの Fiber.yield メソッドの戻り値が ‘World’ の状態で処理が再開されます（つまり変数 second に ‘World’ が代入される）。次はもう Fiber.yield メソッドが呼ばれることはありませんので、ブロックの最後の評価値である “#{first}, #{second}!” すなわち “Hello, World!” を戻り値として呼び出し元に戻ります。</p>

<p>次に Proc の例です。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pr</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">text</span><span class="o">|</span>
  <span class="s2">"Hello</span><span class="si">#{</span><span class="n">text</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">pr</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s1">'!'</span><span class="p">)</span> <span class="c1">#=&gt; "Hello!" と出力</span>
<span class="nb">puts</span> <span class="n">pr</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s1">', World!'</span><span class="p">)</span> <span class="c1">#=&gt; "Hello, World!" と出力</span>
</code></pre></div></div>

<p>変数 pr には、Proc.new により do から end までの処理を抽象化した Proc オブジェクトが代入されます。そして最初に文字列 ‘!’ を引数にその Proc オブジェクトのインスタンスメソッド call を呼び出すと、ブロック引数 text に ‘!’ が代入され、ブロックの実行が開始します。そしてブロックの最後の評価値である “Hello#{text}” すなわち “Hello!” を戻り値として呼び出し元に戻ります。</p>

<p>次に文字列 ‘, World!’ を引数にまた call メソッドを呼び出すと、ブロック引数 text に ‘, World!’ が代入され、またブロックの最初から実行されます。そしてブロックの最後の評価値である “Hello#{text}” すなわち “Hello, World!” を戻り値として呼び出し元に戻ります。</p>

<p>乱暴にまとめてしまうと、Fiber は「手続きと、それをどこまで実行したか」をオブジェクトにしたもので、呼び出すたびに「どこまで実行したか」の状態が少しずつ進んでいくため、プログラムを順番に実行していく手続き型言語の発想をオブジェクト指向言語に持ち込んだものと考えることができます。対して Proc は「一連の手続き」をオブジェクトにしただけのものなので、呼び出すときの引数は変更できますが、手続き自体は毎回最初から実行されます。言わば、何度でも評価できる「関数」のようなもの（後述しますが、厳密には関数とは違うものです）をオブジェクトにしたものなので、関数型言語の発想をオブジェクト指向言語に持ち込んだものと考えることができます。</p>

<h4 id="fiber-によるフィボナッチ数列">Fiber によるフィボナッチ数列</h4>

<p>では、先ほどのフィボナッチ数列を Fiber を使って実装してみましょう。といっても全く同じ問題では Fiber のありがたみが分かりづらいと思いますので、問題を次のように変えてみました。</p>

<blockquote>
  <p>Q. フィボナッチ数列の値を fib(1) から fib(10) まで、1 秒ごとに順に出力するプログラムを書いてください。</p>
</blockquote>

<p>回答は次のようなプログラムになります。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fib</span> <span class="o">=</span> <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
  <span class="kp">loop</span> <span class="k">do</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
    <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="n">fib</span><span class="p">.</span><span class="nf">resume</span>
  <span class="nb">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">end</span>

</code></pre></div></div>

<p>プログラムを見ていただけると分かると思いますが、Fiber.yield メソッドを無限ループの中で呼ぶことで、無限ループ処理を抽象化し、処理を少しずつ実行することができています。言い換えると、Fiber を使うと、手続き型言語によるフィボナッチ数列の計算方法はそのままで、フィボナッチ数列を算出する処理をオブジェクトとして抽象化することができます。</p>

<h4 id="fiber-による-fizzbuzz">Fiber による FizzBuzz</h4>

<p>FizzBuzz 問題のほうも 1 秒ごとに順に出力するバージョンを Fiber を使って実装してみましょう。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fizzbuzz</span> <span class="o">=</span> <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="kp">loop</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">15</span> <span class="o">==</span> <span class="mi">0</span> 
      <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="s1">'FizzBuzz'</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="s1">'Buzz'</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="s1">'Fizz'</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="mi">100</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="n">fizzbuzz</span><span class="p">.</span><span class="nf">resume</span>
  <span class="nb">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">end</span>

</code></pre></div></div>

<p>それでは最後に、フィボナッチ数列と FizzBuzz の合わせ技の問題です。</p>

<blockquote>
  <p>Q. 先ほどのフィボナッチ数列と FizzBuzz を、交互に 5 つずつ 100 個まで出力するプログラムを書いてください。</p>
</blockquote>

<p>このような「処理を途中で止めて別の処理をする」といった「状態」を管理する用途に Fiber は向いています。回答例は次のようになります。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fizzbuzz</span> <span class="o">=</span> <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="kp">loop</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">15</span> <span class="o">==</span> <span class="mi">0</span> 
      <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="s1">'FizzBuzz'</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="s1">'Buzz'</span><span class="p">)</span>
    <span class="k">elsif</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="s1">'Fizz'</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">fib</span> <span class="o">=</span> <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
  <span class="kp">loop</span> <span class="k">do</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
    <span class="no">Fiber</span><span class="p">.</span><span class="nf">yield</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="mi">20</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="n">fib</span><span class="p">.</span><span class="nf">resume</span>
  <span class="k">end</span>
  <span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="n">fizzbuzz</span><span class="p">.</span><span class="nf">resume</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<h4 id="proc-によるフィボナッチ数列と-fizzbuzz">Proc によるフィボナッチ数列と FizzBuzz</h4>

<p>先ほど Proc は「関数のようなもの」と説明しましたが、実は Proc は純粋な関数ではなく<a href="http://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3">クロージャ</a>です。なので、クロージャのレキシカル変数を使うことで「状態」を扱うこともできます。これにより、Proc でも次のように手続き型言語の発想でフィボナッチ数列や FizzBuzz を実装することができます。それでは、先ほどのフィボナッチ数列と FizzBuzz を交互に 5 つずつ 100 個まで出力するプログラムを Proc で実装してみましょう。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fizzbuzz_maker</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
   <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
   <span class="k">case</span>
   <span class="k">when</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">15</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="s2">"FizzBuzz"</span>
   <span class="k">when</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="s2">"Buzz"</span>
   <span class="k">when</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span> <span class="s2">"Fizz"</span>
   <span class="k">else</span> <span class="n">i</span>
   <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">fib_maker</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
  <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
    <span class="n">a</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">fizzbuzz</span> <span class="o">=</span> <span class="n">fizzbuzz_maker</span>
<span class="n">fib</span> <span class="o">=</span> <span class="n">fib_maker</span>

<span class="mi">20</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="n">fib</span><span class="p">.</span><span class="nf">call</span>
  <span class="k">end</span>
  <span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="n">fizzbuzz</span><span class="p">.</span><span class="nf">call</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<p>fizzbuzz_maker メソッドは、FizzBuzz の状態をレキシカル変数 i に保持した Proc オブジェクトを生成します。同様に、fib_maker メソッドは、フィボナッチ数列の算出過程をレキシカル変数 a, b に保持した Proc オブジェクトを生成します。そうして生成された Proc オブジェクトは、一連の手続き自体は毎回同じですが、call メソッドを呼ばれる度にレキシカル変数が変化するため、先ほどの Fiber のように計算を少しずつ進めることができています。しかし Proc のレキシカル変数の考え方は、Fiber の「処理がどこまで進んだか」という考え方と比較すると、直感的に理解するのは難しいのではないでしょうか。</p>

<p>手続き型言語の発想、関数型言語の発想、それぞれの発想にはそれぞれの良さがあり、ぴたっとはまる用途はケースバイケースです。ひとつの発想をむりやり当てはめるよりも、発想の引き出しをたくさん持っている方が優れていることは言うまでもありません。冒頭に出てきた複数のプログラミング言語 (それも異なるパラダイムに属する言語) を学ぶことのメリットは、まさにここにあると言えるでしょう。</p>

<h3 id="終わりに">終わりに</h3>

<p>今回は「手続きの抽象化」という視点から Fiber と Proc の解説をしてみました。Proc は日常的に使っている方でも、Ruby 1.9 からの新機能である Fiber はなじみのない方が多いのではないでしょうか。</p>

<p>より実践的な Fiber の使い方は、Fiber が使われているソースコード (たとえば<a href="https://gist.github.com/835268">チャットサーバ</a>など) を探して読んでみるのが勉強になります。良さそうなコードがありましたら、ぜひ教えてください。</p>

<h3 id="著者について">著者について</h3>

<h4 id="郡司啓gunjisatoshi">郡司啓(<a href="http://twitter.com/gunjisatoshi/">@gunjisatoshi</a>)</h4>

<h2 id="asakusarb-のすみっこで-twitter-実況中継する係りの人asakusarb-は毎週火曜日-1930-頃から開催されていますのでご興味のある方でお近くをお通りの際は是非お立ち寄りを"><a href="http://asakusa.rubyist.net/">Asakusa.rb</a> のすみっこで Twitter 実況中継する係りの人。Asakusa.rb は毎週火曜日 19:30 頃から開催されていますので、ご興味のある方でお近くをお通りの際は是非お立ち寄りを。</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>もちろんこの実装は無邪気に過ぎるのですが (末尾再帰とかメモ化とかの最適化や、引数チェックなどの例外処理とかを考慮していない) 、今回の話の本質ではないのでそのあたりの説明は省略します。興味のある方は調べてみると面白いでしょう。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
  </body>
</html>
