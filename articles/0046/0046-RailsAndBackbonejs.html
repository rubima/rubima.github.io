<!DOCTYPE html>
<html>
  



  <head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-41117431-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-41117431-1');
  </script>
  <script src="../../js/gtag.js"></script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Backbone.js on Rails 始めの一歩</title>
  <meta name="description" content="">

  <script src="../../js/jquery.min.js"></script>
  <script src="../../js/bootstrap.min.js"></script>
  <link href="../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../../css/theme.css" rel="stylesheet" type="text/css">
  <link href="../../css/syntax.css" rel="stylesheet" type="text/css">
  <link href="../../css/sharebutton.css" rel="stylesheet" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="https://magazine.rubyist.net/articles/0046/0046-RailsAndBackbonejs.html">
  <link rel="alternate" type="application/rss+xml" title="Rubyist Magazine" href="https://magazine.rubyist.net/feed.xml">
  <link rel="shortcut icon" href="../../images/favicon.ico">
</head>

  <body>
    <div class="container-fluid">
        <div class="row full">
            <div class="col-md-2 hidden-xs sidebar">
                <h4>

</h4>

<h4>バックナンバー</h4>
<ul>
    
        <li><a href="../../articles/0058/0058-index.html">0058号(2018-08)</a></li>
    
        <li><a href="../../articles/prerubykaigi2018/preRubyKaigi2018-index.html">RubyKaigi 2018 直前特集号</a></li>
    
        <li><a href="../../articles/0057/0057-index.html">0057号(2018-02)</a></li>
    
        <li><a href="../../articles/prerubykaigi2017/preRubyKaigi2017-index.html">RubyKaigi 2017 直前特集号</a></li>
    
        <li><a href="../../articles/0056/0056-index.html">0056号(2017-08)</a></li>
    
        <li><a href="../../articles/0055/0055-index.html">0055号(2017-03)</a></li>
    
        <li><a href="../../articles/0054/0054-index.html">0054号(2016-08)</a></li>
    
        <li><a href="../../articles/pretokyorubykaigi11/preTokyoRubyKaigi11-index.html">東京 Ruby 会議 11 直前特集号</a></li>
    
        <li><a href="../../articles/0053/0053-index.html">0053号(2016-04)</a></li>
    
        <li><a href="../../articles/0052/0052-index.html">0052号(2015-12)</a></li>
    
        <li><a href="../../articles/0051/0051-index.html">0051号(2015-09)</a></li>
    
        <li><a href="../../articles/0050/0050-index.html">0050号(2015-05)</a></li>
    
        <li><a href="../../articles/0049/0049-index.html">0049号(2014-12)</a></li>
    
        <li><a href="../../articles/0048/0048-index.html">0048号(2014-09)</a></li>
    
        <li><a href="../../articles/0047/0047-index.html">0047号(2014-06)</a></li>
    
        <li><a href="../../articles/0046/0046-index.html">0046号(2014-04)</a></li>
    
        <li><a href="../../articles/0045/0045-index.html">0045号(2013-12)</a></li>
    
        <li><a href="../../articles/0044/0044-index.html">0044号(2013-09)</a></li>
    
        <li><a href="../../articles/0043/0043-index.html">0043号(2013-07)</a></li>
    
        <li><a href="../../articles/0042/0042-index.html">0042号(2013-05)</a></li>
    
        <li><a href="../../articles/ruby200specialen/Ruby200SpecialEn-index.html">2.0.0 Special (EN)</a></li>
    
        <li><a href="../../articles/0041/0041-index.html">0041号(2013-02)</a></li>
    
        <li><a href="../../articles/0040/0040-index.html">0040号(2012-11)</a></li>
    
        <li><a href="../../articles/0039/0039-index.html">0039号(2012-09)</a></li>
    
        <li><a href="../../articles/rubykaja/kaja.html">RubyKaja のご紹介</a></li>
    
        <li><a href="../../articles/0038/0038-index.html">0038号(2012-05)</a></li>
    
        <li><a href="../../articles/0037/0037-index.html">0037号(2012-02)</a></li>
    
        <li><a href="../../articles/0036/0036-index.html">0036号(2011-11)</a></li>
    
        <li><a href="../../articles/0035/0035-index.html">0035号(2011-09)</a></li>
    
        <li><a href="../../articles/prerubykaigi2011/preRubyKaigi2011-index.html">RubyKaigi2011直前特集号</a></li>
    
        <li><a href="../../articles/0034/0034-index.html">0034号(2011-06)</a></li>
    
        <li><a href="../../articles/0033/0033-index.html">0033号(2011-04)</a></li>
    
        <li><a href="../../articles/0032/0032-index.html">0032号(2011-01)</a></li>
    
        <li><a href="../../articles/0031/0031-index.html">0031号(2010-10)</a></li>
    
        <li><a href="../../articles/prerubykaigi2010/preRubyKaigi2010-index.html">RubyKaigi2010直前特集号</a></li>
    
        <li><a href="../../articles/0030/0030-index.html">0030号(2010-06)</a></li>
    
        <li><a href="../../articles/0029/0029-index.html">0029号(2010-03)</a></li>
    
        <li><a href="../../articles/0028/0028-index.html">0028号(2009-12)</a></li>
    
        <li><a href="../../articles/0027/0027-index.html">0027号(2009-09)</a></li>
    
        <li><a href="../../articles/0026/0026-index.html">0026号(2009-06)</a></li>
    
        <li><a href="../../articles/0025/0025-index.html">0025号(2009-02)</a></li>
    
        <li><a href="../../articles/0024/0024-index.html">0024号(2008-10)</a></li>
    
        <li><a href="../../articles/0023/0023-index.html">0023号(2008-03)</a></li>
    
        <li><a href="../../articles/0022/0022-index.html">0022号(2007-12)</a></li>
    
        <li><a href="../../articles/0021/0021-index.html">0021号(2007-09)</a></li>
    
        <li><a href="../../articles/0020/0020-index.html">0020号(2007-08)</a></li>
    
        <li><a href="../../articles/0019/0019-index.html">0019号(2007-05)</a></li>
    
        <li><a href="../../articles/0018/0018-index.html">0018号(2007-02)</a></li>
    
        <li><a href="../../articles/0017/0017-index.html">0017号(2006-11)</a></li>
    
        <li><a href="../../articles/0016/0016-index.html">0016号(2006-09)</a></li>
    
        <li><a href="../../articles/0015/0015-index.html">0015号(2006-07)</a></li>
    
        <li><a href="../../articles/rubykaigi2006/RubyKaigi2006-index.html">日本 Ruby カンファレンス 2006 特別号</a></li>
    
        <li><a href="../../articles/0014/0014-index.html">0014号(2006-05)</a></li>
    
        <li><a href="../../articles/0013/0013-index.html">0013号(2006-02)</a></li>
    
        <li><a href="../../articles/0012/0012-index.html">0012号(2005-12)</a></li>
    
        <li><a href="../../articles/0011/0011-index.html">0011号(2005-11)</a></li>
    
        <li><a href="../../articles/0010/0010-index.html">0010号(2005-10)</a></li>
    
        <li><a href="../../articles/0009/0009-index.html">0009号(2005-09)</a></li>
    
        <li><a href="../../articles/0008/0008-index.html">0008号(2005-07)</a></li>
    
        <li><a href="../../articles/0007/0007-index.html">0007号(2005-06)</a></li>
    
        <li><a href="../../articles/0006/0006-index.html">0006号(2005-05)</a></li>
    
        <li><a href="../../articles/0005/0005-index.html">0005号(2005-02)</a></li>
    
        <li><a href="../../articles/0004/0004-index.html">0004号(2004-12)</a></li>
    
        <li><a href="../../articles/0003/0003-index.html">0003号(2004-11)</a></li>
    
        <li><a href="../../articles/0002/0002-index.html">0002号(2004-10)</a></li>
    
        <li><a href="../../articles/0001/0001-index.html">0001号(2004-09)</a></li>
    
</ul>
<p class="rss-subscribe"><a href="/feed.xml">RSS</a></p>

            </div>
            <div class="col-md-10 main">
                <div class="row">
                    <div class="col-md-12">
                        <img src="../../images/rubima_logo_l.png">
                        <h1>Backbone.js on Rails 始めの一歩</h1>
                        <div class="social-buttons">
                            <div class='sns'>            
    <ul class="clearfix">
       <li class="twitter"><a href="https://twitter.com/share?text=Backbone.js on Rails 始めの一歩&amp;url=https://magazine.rubyist.net/articles/0046/0046-RailsAndBackbonejs.html" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa fa-twitter"></i></a></li>
       <li class="facebook"><a href="https://www.facebook.com/sharer.php?u=https://magazine.rubyist.net/articles/0046/0046-RailsAndBackbonejs.html&amp;t=Backbone.js on Rails 始めの一歩" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa fa-facebook"></i></a></li>
       <li class="hatebu"><a href="http://b.hatena.ne.jp/add?mode=confirm&amp;url=https://magazine.rubyist.net/articles/0046/0046-RailsAndBackbonejs.html&amp;Backbone.js on Rails 始めの一歩" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa">B!</i></a></li>
    </ul>
</div>
                        </div>
                        <div class="post_info">
                            



                        </div>
                        
<ul id="markdown-toc">
  <li><a href="#はじめに" id="markdown-toc-はじめに">はじめに</a></li>
  <li><a href="#backbonejs-について" id="markdown-toc-backbonejs-について">Backbone.js について</a>    <ul>
      <li><a href="#backbonejs-の構成要素" id="markdown-toc-backbonejs-の構成要素">Backbone.js の構成要素</a></li>
      <li><a href="#rails-アプリに-backbonejs-を導入するいくつかの方法" id="markdown-toc-rails-アプリに-backbonejs-を導入するいくつかの方法">Rails アプリに Backbone.js を導入するいくつかの方法</a></li>
    </ul>
  </li>
  <li><a href="#サンプルアプリの解説" id="markdown-toc-サンプルアプリの解説">サンプルアプリの解説</a>    <ul>
      <li><a href="#rails-側の実装" id="markdown-toc-rails-側の実装">Rails 側の実装</a></li>
      <li><a href="#backbonejs-側のモデルの実装" id="markdown-toc-backbonejs-側のモデルの実装">Backbone.js 側のモデルの実装</a></li>
      <li><a href="#backbonejs-側のビューの実装" id="markdown-toc-backbonejs-側のビューの実装">Backbone.js 側のビューの実装</a></li>
      <li><a href="#データバインディング" id="markdown-toc-データバインディング">データバインディング</a></li>
      <li><a href="#ルーターによるディスパッチ" id="markdown-toc-ルーターによるディスパッチ">ルーターによるディスパッチ</a></li>
    </ul>
  </li>
  <li><a href="#まとめ" id="markdown-toc-まとめ">まとめ</a>    <ul>
      <li><a href="#本格的に-backbonejs-を利用するなら" id="markdown-toc-本格的に-backbonejs-を利用するなら">本格的に Backbone.js を利用するなら</a></li>
      <li><a href="#rails-開発における-javascript-のテストについて" id="markdown-toc-rails-開発における-javascript-のテストについて">Rails 開発における JavaScript のテストについて</a></li>
    </ul>
  </li>
  <li><a href="#著者について" id="markdown-toc-著者について">著者について</a>    <ul>
      <li><a href="#橋立-友宏-joker1007" id="markdown-toc-橋立-友宏-joker1007">橋立 友宏 (@joker1007)</a></li>
    </ul>
  </li>
</ul>

<p>書いた人: joker1007 (<a href="https://twitter.com/joker1007">@joker1007</a>)</p>

<h2 id="はじめに">はじめに</h2>

<p>るびまへの記事リクエストで Backbone.js と Rails についての記事が読んでみたい、という話がありました。
どちらもそれなりに利用した経験があるので、今回記事を書かせていただくことになった @joker1007 です。</p>

<p>今回は、 Backbone.js の簡単な紹介と、 Rails で利用するための環境の整え方、そして Backbone.js の基本的な書き方について、紹介していきます。</p>

<p>また、サンプルとして簡単な CRUD アプリにちょっと機能を追加したアプリケーションを用意しておきました。実装サンプルが見てみたい方は参考にしてみてください。</p>

<p><a href="https://github.com/joker1007/simple_note/">joker1007/simple_note</a></p>

<h2 id="backbonejs-について">Backbone.js について</h2>

<p>最初に、 Backbone.js について簡単に説明します。 Backbone.js は JavaScript をより良く構造化するためのフレームワークです。基本的な考え方は MVC をベースにしていると言われていますが、 Rails 等のサーバーサイドフレームワークにおける MVC とは少し勝手が違います。どちらかというと GUI アプリケーションの考え方に近いと言えるのではないかと思います。</p>

<p>Backbone.js の特徴は、非常にシンプルであることです。最近は、 JavaScript のフレームワークが数多く登場しており、 Angular.js や Ember.js 等も注目を集めていますが、 Backbone.js は Angular.js や Ember.js 等に比べて、それ自体が提供する機能がとてもコンパクトです。そのため、 Backbone.js は単体で利用すると、自分自身でイベントバインディングを定義したりビューの切り替えを制御する処理を実装しなければならない機会が沢山あります。しかし、一方ではこういった Backbone.js のコンパクトさは、ブラックボックスが少ないという利点でもあります。自分の理解していない所で勝手に色々な処理が進むことがありません。また本体のソースコード自体も非常にコンパクトで、 JavaScript に慣れた人なら半日もかからずに全てを読み切ることができるでしょう。</p>

<p>こういったシンプルさから、 Backbone.js は初期学習コストが低く済むため、 JavaScript のフレームワークの概要を掴むための入口として最適なフレームワークだと思います。</p>

<h3 id="backbonejs-の構成要素">Backbone.js の構成要素</h3>

<p>Backbone.js の基本的な構成要素は以下の通りです。</p>

<table>
  <thead>
    <tr>
      <th>コンポーネント</th>
      <th>役割</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Model/Collection</td>
      <td>サーバーとの通信や、 LocalStorage とのデータのやり取り、データに関するロジックを扱う</td>
    </tr>
    <tr>
      <td>View</td>
      <td>DOM で発生したイベントのハンドリングを行ったり、テンプレートエンジンにレンダリングに必要なデータを受け渡す等の処理を行う。</td>
    </tr>
    <tr>
      <td>Router</td>
      <td>URL の変更を検知して何らかの処理をディスパッチする</td>
    </tr>
  </tbody>
</table>

<p>テンプレートエンジンは用意されていないため、好きなものを利用します。</p>

<p>Backbone.js の各構成要素の役割を Rails における MVC の役割と無理矢理対応付けると、以下のような形になります。</p>

<table>
  <tbody>
    <tr>
      <td>Backbone.js</td>
      <td>Rails</td>
    </tr>
    <tr>
      <td>Model/Collection</td>
      <td>Model</td>
    </tr>
    <tr>
      <td>Template</td>
      <td>View</td>
    </tr>
    <tr>
      <td>View</td>
      <td>Controller</td>
    </tr>
  </tbody>
</table>

<p>Model/Collection や Template の役割は、 Rails とそれ程変わりませんが、 Backbone.js における View は Rails のそれとは少し違ったものです。</p>

<p>名前から誤解を生みそうですが、 Backbone.js における View は Rails における Controller に近いポジションです。 Backbone.js では View はモデルへの参照を持っており、ユーザーの操作によるイベントの発生をモデルに対して伝える橋渡しの役割も果たします。テンプレートのレンダリングを指示するのも View の仕事です。</p>

<p>そして、利用用途に依りますが、 Backbone.js では比較的 View に書くコード量が多くなる傾向にあります。何故なら JavaScript が活用されるポイントの多くは、ユーザーの操作に対応して DOM を変化させる事だからです。</p>

<p>それでは、 Backbone.js の概要と構成要素についての説明はこのぐらいにして、 Rails で実際に Backbone.js を利用するにはどうすれば良いのかを見ていきましょう。</p>

<h3 id="rails-アプリに-backbonejs-を導入するいくつかの方法">Rails アプリに Backbone.js を導入するいくつかの方法</h3>

<p>Rails アプリケーションに JavaScript ライブラリを導入する方法はいくつかあります。</p>

<ol>
  <li>ダウンロードして vendor / assets 以下に直接配置する</li>
  <li>JavaScript ライブラリが組み込まれた gem を探して導入する</li>
  <li>bower 等の JavaScript ライブラリ管理ツールを利用する</li>
  <li>rails-assets.org を利用して、 bower パッケージを gem としてインストールする</li>
</ol>

<p>Backbone.js を組込んだ gem はいくつかありますが、代表的なのは <a href="https://github.com/codebrew/backbone-rails">rails-backbone</a> と <a href="https://github.com/meleyal/backbone-on-rails">backbone-on-rails</a> です。
rails-backbone は GitHub のプロジェクト名としては backbone-rails です。ちなみに gem の名前として backbone-rails を指定してインストールすると違う gem がインストールされてしまいますので注意してください。Backbone.js を利用するだけなら大して差は無いのですが、微妙にバージョンや同梱されているものに差異があります。</p>

<p>私が最近活用しているのは 4 の rails-assets.org の利用です。主な理由は以下の四つです。</p>

<ul>
  <li>ライブラリのバージョンアップが容易である</li>
  <li>依存関係が自動的に解決される</li>
  <li>余計なものがインストールされない</li>
  <li>gem のアップデートサイクルに縛られずに済む</li>
</ul>

<p>JavaScript ライブラリのバージョンアップにどうやって追従するか、というのは中々悩ましい問題です。最近は、 bower の登場によりかなり楽になってきました。しかし、できるだけ Rails のエコシステムだけで完結してくれる方が Rails 開発者にとっては楽です。その折衷案として rails-assets.org を利用するのは、今の所中々良いのではないかと感じています。</p>

<p>というわけで、今回は rails-assets を利用して Backbone.js を Rails アプリケーションに組み込んでみましょう。 Rails プロジェクトの Gemfile を以下のように編集します。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">source 'https://rubygems.org'
source 'https://rails-assets.org'  # rails-assets.org を source として指定しておく

# .. 省略 ..

# rails-assets
gem 'rails-assets-lodash'
gem 'rails-assets-backbone'</code></pre></figure>

<p>bundle install を行えば、 JavaScript のライブラリが gem としてインストールされます。
lodash というライブラリも一緒にインストールしていますが、これは underscore.js の代替となるライブラリです。 underscore.js と互換性があり、更に多機能化、高速化された実装になっています。 Backbone.js は underscore.js に依存しているのですが、 lodash も利用できます。今回はこちらを利用してみます。</p>

<p>インストールが完了したら、アセットパイプラインのマニフェストファイルを編集します。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">//= require jquery
//= require jquery_ujs
//= require lodash
//= require backbone
//= require_tree .</code></pre></figure>

<p>これで Rails アプリケーション内で Backbone.js を利用できるようになります。</p>

<h2 id="サンプルアプリの解説">サンプルアプリの解説</h2>

<p>冒頭で紹介しましたが、 Backbone.js を利用した簡単なアプリケーションを用意しました。 markdown を即座にプレビューしながら編集できるメモアプリケーションです。
このアプリケーションを元に Backbone.js でアプリケーションを書くとどんな感じになるのかを解説していきます。
Heroku にホストしているので、どういった動作をするか確認したい方は<a href="http://simple-note.herokuapp.com/">こちら</a>を見てください。</p>

<p>全てを解説すると余りに長くなってしまうので、要所に絞って解説していきます。 Backbone.js コンポーネントのメソッドの詳細については、分量もそれ程多くないため、ここで解説するよりも、公式のリファレンスとソースコードを読むのが最も良い資料になります。</p>

<p>Backbone.js の API リファレンスは<a href="http://backbonejs.org/">こちら</a></p>

<h3 id="rails-側の実装">Rails 側の実装</h3>

<p>今回は、 Rails 側はほぼ API サーバーとしての役割だけを担っています。 json を返すレスポンスは scaffold で作成した jbuilder テンプレートに任せています。 html テンプレートはレイアウトだけを描画し、何も返していません。ブラウザに表示する内容も含めて、全て JavaScript で処理しています。</p>

<p>Rails 側で実装したのは、 markdown をパースした結果の html を返す API だけです。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># app/controllers/notes_controller.rb:17
def rendering
  @note = Note.new do |n|
    n.raw_body = params[:raw_body]
  end
end</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># app/views/notes/rendering.json.jbuilder
json.body @note.render_markdown</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># app/models/note.rb:19
def render_markdown
  markdown_processor.render(raw_body)
end

private
def update_body_by_render_markdown
  self.body = render_markdown
end

def markdown_processor
  @markdown_processor ||= Redcarpet::Markdown.new(
    Redcarpet::Render::HTML.new(
      filter_html:  true,
      hard_wrap:    true,
    ),
    autolink:            true,
    tables:              true,
    underline:           true,
    highlight:           true,
    fenced_code_blocks:  true,
  )
end</code></pre></figure>

<h3 id="backbonejs-側のモデルの実装">Backbone.js 側のモデルの実装</h3>

<p>Backbone.js 側の実装を見ていきましょう。まずはシンプルなモデルからです。</p>

<p>モデルの主な仕事はサーバーサイドとの通信です。今回のアプリケーションだと一覧の取得と、サーバーサイドにデータを永続化すること、そして保持している markdown を元に html のレンダリングをサーバーサイドに依頼し、結果を受け取ることです。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">s = @SimpleNote
s.Models ?= {}

s.Models.Note = Backbone.Model.extend
  urlRoot: '/notes'

  initialize: -&gt;
    @listenTo @, 'change:raw_body', _.debounce =&gt;
      @renderBody()
    , 300

  previewText: (length = 140) -&gt;
    @get("raw_body")?.substring(0, length)

  renderBody: -&gt;
    $.ajax("/notes/rendering", 
      type: "POST"
      dataType: 'json'
      data: {raw_body: @get('raw_body')}
    ).done (data) =&gt;
      @set('body', data.body)

s.Collections.NoteCollection = Backbone.Collection.extend
  model: s.Models.Note
  url: '/notes'</code></pre></figure>

<p>Backbone.js のモデルはサーバーサイドに対する基本的な CRUD 操作の機能を既に用意してくれているため、基本的な処理はエンドポイントとなる URL を定義するだけで完了します。</p>

<p>markdown のレンダリングをサーバーサイドに依頼する部分が Note クラスの実装のメインです。といっても、単純に ajax でリクエストを送って、結果を body 属性に格納しているだけです。</p>

<p>そして、コンストラクタでメモ内容の本文が更新されたら、 300ms 待ってからサーバーに自動でリクエストを送るようにイベントハンドラを定義しています。 debounce でラップしているのは、高速で値が変化した時にリクエストが重複されないための工夫です。</p>

<h3 id="backbonejs-側のビューの実装">Backbone.js 側のビューの実装</h3>

<p>Backbone.js のビューを考える時に重要なのは、入れ子の構造を意識する事です。例えばノートの一覧を表示する画面には、ノートの集合を扱うビューがあり、その中に一つ一つのノートに対応したビューがある、という感じです。</p>

<p>サンプルアプリケーションのノートの一覧を表示するためのビューの実装を見てみましょう。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># app/assets/javascripts/views/notes/index_view.js.coffee
s = @SimpleNote
s.Views.Notes ?= {}

s.Views.Notes.IndexView = Backbone.View.extend
  template: JST['notes/index']

  events:
    'click a.new-note-btn' : 'navigateToNewNote'

  initialize: (@options) -&gt;
    @listenTo @collection, "reset", =&gt;
      @render()

  render: -&gt;
    @$el.html(@template())
    @collection.each (note) =&gt;
      view = new s.Views.Notes.IndexItemView(model: note)
      @$(".notes").append(view.render().el)
    @$("#note-menu")
    this

  navigateToNewNote: -&gt;
    Backbone.history.navigate('notes/new', true)</code></pre></figure>

<p>こちらはコレクションに対する描画を行うビューです。このビューのレンダリングを行う中で、個別のノートに対応したビューを構築しそれぞれをレンダリングして自身の管理している DOM の中に追加しています。</p>

<p>ポイントは、 initialize メソッドの中で実行している listenTo メソッドです。与えられたコレクションオブジェクトが再同期されたら、 render を再度実行するようにイベントハンドラを定義しています。</p>

<p>このようにモデルやコレクションに変化が発生した時に適切にビューを更新するために、各操作に連動してトリガーされるイベントを経由して処理を実行するのが、 Backbone.js の基本的な考え方になります。</p>

<p>続いて、個別のノートに対応したビューを見てみましょう。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># app/assets/javascripts/views/notes/index_item_view.js.coffee
s = @SimpleNote
s.Views.Notes ?= {}

s.Views.Notes.IndexItemView = Backbone.View.extend
  tagName: 'li'
  id: -&gt; "note-#{@model.id}"
  className: 'note'
  template: JST['notes/index_item']

  events:
    'click .note-title' : 'navigateToNote'
    'click .delete-note' : 'deleteNote'

  initialize: -&gt;
    @listenTo @model, 'destroy', =&gt;
      @remove()

  render: -&gt;
    context = @model.toJSON()
    _.extend(context, previewText: @model.previewText())
    @$el.html(@template(context))
    this

  navigateToNote: (e) -&gt;
    e.preventDefault()
    Backbone.history.navigate("notes/#{@model.id}", true)

  deleteNote: (e) -&gt;
    e.preventDefault()
    if confirm('ノートを削除しますか？')
      @model.destroy()</code></pre></figure>

<p>こちらのポイントはテンプレートを使った描画とユーザーの操作に対するイベントハンドラの定義です。</p>

<p>このアプリケーションでは JavaScript で利用するテンプレートに Sprockets によってコンパイルされる JST を利用しています。このテンプレートに対して、描画に必要な情報をシリアライズして渡す事で、描画を行っています。</p>

<p>Backbone.js のビューでは、 events プロパティにオブジェクトを渡すことで、ユーザーの操作で発生するイベントに対するハンドラを定義します。キーがイベント名と DOM のセレクタを指定し、値がハンドラメソッドの名前を指定します。このイベントがキャッチされるのは、 this.el に含まれる DOM に対してだけです。</p>

<p>またモデルが削除された時に、ノートの描画を画面から削除するためのイベントハンドラも定義されています。</p>

<h3 id="データバインディング">データバインディング</h3>

<p>JavaScript のフレームワークではビュー側で行われた変更とモデル側で行われた変更を上手く同期させる事がとても重要です。この同期処理が必要になるケースは頻繁に存在します。 Angular.js や Ember.js はフレームワーク自体が、そのための機能を提供していますが、 Backbone.js にはそういった機能は組み込まれていません。そこで Backbone.js を利用する場合は、 Backbone.js を拡張するライブラリを利用します。データバインディングのためのライブラリで良く利用されているのが<a href="http://nytimes.github.io/backbone.stickit/">backbone.stickit</a>です。</p>

<p>backbone.stickit を利用することで、ユーザーがフォームに入力したデータをモデルに反映させたり、逆にモデルが変更された時にビューの描画を即座に更新する、といった処理が簡単に定義できるようになります。ノートの入力フォームを表示しているビューの実装を見てみましょう。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># app/assets/javascripts/views/notes/note_view.js.coffee
s = @SimpleNote
s.Views.Notes ?= {}

s.Views.Notes.NoteView = Backbone.View.extend
  className: 'new-note'
  template: JST['notes/note']

  events:
    'click .submit-note-form' : 'submit'
    'click .back' : 'navigateToNoteIndex'

  bindings:
    '#input-note-title' : 'title'
    '#input-note-raw_body' : 'raw_body'

  render: -&gt;
    @listenTo @model, 'sync', _.bind(@_onModelSynced, @)
    @listenTo @model, 'error', _.bind(@_onModelErrored, @)

    @$el.html(@template(@model.toJSON()))
    preview = new s.Views.Notes.PreviewView(model: @model, el: @$('.preview-col'))
    preview.render()
    @stickit()
    this

  submit: (e) -&gt;
    e.preventDefault()
    @trigger('clickSubmit')

  navigateToNoteIndex: (e) -&gt;
    e.preventDefault()
    Backbone.history.navigate('notes', true)

  _onModelSynced: -&gt;
    @$('.submit-note-form').notify("Success!", className: 'success', position: "right")

  _onModelErrored: -&gt;
    @$('.submit-note-form').notify("Error!", className: 'error', position: "right")</code></pre></figure>

<p>bindings プロパティの定義に注目してみてください。オブジェクトを返すようになっています。キーが入力フィールドのセレクタ、値が対応するモデルの属性名です。そして、 render メソッドの最後で実行している stickit メソッドで bindings の定義を有効化しています。</p>

<p>これだけで、#input-note-title が示す入力フィールドに入力された値がモデルの title 属性に即座に反映されるようになります。また逆も然りです。</p>

<p>stickit メソッドの呼び出しを忘れると、バインディングのためのイベントハンドラが定義されないので注意してください。</p>

<p>この様にフォームと組み合わせて利用するのが典型的ですが、 PreviewView によるタイトルの表示で利用しているように実際にはフォームに関わらず利用する事ができます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">s = @SimpleNote
s.Views.Notes ?= {}

s.Views.Notes.PreviewView = Backbone.View.extend
  template: JST['notes/preview']

  bindings:
    '#note-title' : 'title'

  initialize: -&gt;
    @listenTo @model, 'change:body', _.bind(@_updatePreview, @)

  render: -&gt;
    @$el.html(@template(@model.toJSON()))
    @_updatePreview()
    @stickit()

  _updatePreview: -&gt;
    @$('#note-body').html(@model.get("body"))
    @$("code").each (i, e) -&gt;
      hljs.highlightBlock(e)</code></pre></figure>

<h3 id="ルーターによるディスパッチ">ルーターによるディスパッチ</h3>

<p>これまでに定義してきたビューを画面に描画するためのディスパッチ処理を行っているルーターについても知っておきましょう。</p>

<p>ディスパッチにおいて重要なのは、 JS の読み込みとアプリケーションの起動を分けておくことです。そうしておかないと、 JavaScript の単体テストのコードを書くのが非常に難しくなってしまいます。</p>

<p>Backbone.js のルーターは URL のパターンを定義し、それにマッチする URL であれば定義してあるメソッドを呼び出す仕組みになっています。ルーターは定義しただけでは動作しません。ルーターを実際に利用するには、ルーターのインスタンスを作成してから_Backbone.history.start ()_;を実行します。</p>

<p>URL を JS から遷移させたい時は、_Backbone.history.navigate_を呼び出します。イベントをトリガーするかどうかは、オプションで指定できます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># app/assets/javascripts/routers/note_router.js.coffee
s = @SimpleNote
s.Routers ?= {}

s.Routers.NoteRouter = Backbone.Router.extend
  routes:
    "notes/new" : "newNote"
    "notes/:id" : "showNote"
    "notes" : "indexNotes"
    ".*" : "indexNotes"

  initialize: (options) -&gt;
    @layout = new s.Views.LayoutView(el: $("body"))
    @notes = new s.Collections.NoteCollection()

  indexNotes: -&gt;
    indexView = new s.Views.Notes.IndexView(collection: @notes)
    @layout.setView(indexView)

    @notes.fetch(reset: true)

  newNote: -&gt;
    @note = new s.Models.Note()
    @__renderNoteView()
    @listenTo @note, 'sync', =&gt;
      @navigate("notes", true)

  showNote: (id) -&gt;
    @note = @notes.get(id)
    if @note
      @__renderNoteView()
    else
      @note = new s.Models.Note(id: id)
      @note.fetch
        success: =&gt; @__renderNoteView()

  __renderNoteView: -&gt;
    noteView = new s.Views.Notes.NoteView(model: @note)
    @layout.setView(noteView)
    @listenTo @currentView, 'clickSubmit', =&gt;
      @note.save()</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># app/assets/javascripts/simple_note.js.coffee
window.SimpleNote =
  Models: {}
  Collections: {}
  Views: {}
  Routers: {}
  init: -&gt;
    @router = new SimpleNote.Routers.NoteRouter()
    Backbone.history.start(pushState: true)</code></pre></figure>

<p>pushState API に対応しているブラウザであれば、 URL のパス部分を直接利用してマッチするかどうかを判別できます。 pushState を利用しない場合は、 URL の末尾にハッシュを付与して、ハッシュ部分にパスを擬似的に設定しマッチするかどうかの処理に利用します。</p>

<p>今回は簡単なアプリケーションなので、 pushState を前提にしていますが、古い IE 等に対応しなければならない場合は、 pushState が利用できなくても適切にディスパッチが行われるように工夫する必要があります。</p>

<p>Rails と組み合わせる場合、 pushState が利用できないと、ブラウザのリロードが発生した時に、実行されるアクションが固定されてしまうので、どういったアクセスパターンがあるかを考え、ディスパッチの動作を設計しなければいけません。</p>

<p>例えば、パフォーマンスにこだわる場合は、 Rails に対してアクセスが来た際に、その URL に対応したリソースを JSON にシリアライズした値を直接テンプレートに埋め込んで、 JavaScript のディスパッチ処理に渡す場合があります。それによって初回の無駄なリクエストを減らす事ができます。しかし、この場合 URL がどのように遷移しているか、ブラウザのリロードや特定の URL へのダイレクトアクセスに対してどのように対応するか、を考えておく必要があります。</p>

<p>ちなみに URL を遷移する必要が無く、アプリケーションのエンドポイントが固定できるなら、ルーターを使わずに直接ディスパッチのためのメソッドを呼び出すことも一つの手段です。</p>

<h2 id="まとめ">まとめ</h2>

<p>Backbone.js を始めとする JavaScript のフレームワークで守っておくべき基本的な事項は、レイヤーの責任を守る、ということです。</p>

<p>ここまでで紹介してきたように、モデルはデータを取り扱い保持すること、そしてサーバーサイドと通信する事等が主な役割です。そしてビューは DOM の操作や DOM で発生したイベントを受け取って処理を行うことがその役割です。</p>

<p>モデルクラスが DOM の要素について知らなければいけなかったり、ビュークラスから直接 ajax の通信が実行されている様な状況になっていると、境界が守れていないサインです。</p>

<p>また、ビュークラスが扱う DOM は el 属性として渡された DOM の内部に限定して処理を行うべきです。でないと、イベントの定義が分散して、どの処理がどこに実装されているかが分からなくなる事に繋がります。ビューの担当範囲についても責任範囲を守ることが大事です。
更に、 el 属性内部にのみ限定して処理を行うようにしておくと、テストコードを記述する際に親になる DOM を用意する必要が無くなり、テストが容易になるというメリットもあります。</p>

<p>各コンポーネントが連携して動作しなければならない場合は、できるだけイベントを拾って処理するのが基本です。イベントを経由する形にすることで、各コンポーネントはお互いの詳細や自身に依存する対象の存在を知る必要が無くなります。</p>

<h3 id="本格的に-backbonejs-を利用するなら">本格的に Backbone.js を利用するなら</h3>

<p>さっきのアプリケーションではいくつかイケてない部分があります。
例えば、ルータークラス自体が、アプリケーション全体の画面切り替えを兼ねています。簡単なアプリケーションならそこまで見通しに影響はありませんが、複雑なアプリケーションになると、ルータークラスが肥大化する危険性があります。
また、全体の画面を切り替える処理等の様に、汎用的に利用されそうな部分まで色々と自分で実装しなければならないのは少し面倒です。段階的に機能拡張していくと継ぎ接ぎな実装になる危険もあります。</p>

<p>この様に Backbone.js はそのシンプルさ故に、よくある処理を何度も実装する必要があったり、アプリケーションが複雑になると、実装が混乱して上手く構造化できなくなったりする場合があります。</p>

<p>そのため、本格的に Backbone.js を利用してアプリケーションを開発する場合は、 Backbone.js を拡張するライブラリや、 Backbone.js の上に色々な機能を追加した機能強化版のフレームワークを利用するのが良いでしょう。</p>

<p>Backbone.js を基に機能を追加したフレームワークはいくつかありますが、その中でもメジャーなものは以下の二つだと思います。</p>

<ul>
  <li>Marionette.js</li>
  <li>Chaplin.js</li>
</ul>

<p>この二つを比べると、 Marionette.js の方がシンプル寄りで、 Chaplin.js の方が多機能です。私は比較的覚える事が少なく、通常の Backbone.js の延長感覚で利用できる Marionette.js を利用しています。</p>

<p>これらのライブラリはコントローラー層を記述するためのコンポーネントを用意してくれていたり、アプリケーションの名前空間を定義して、アプリケーション全体の開始や設定をまとめる場所を用意してくれたり、サーバーサイドでレンダリングされた初期 HTML を利用して画面を切り替えるためのレイアウト機能等を持っています。</p>

<p>こういったフレームワークを利用する事で、より複雑なアプリケーションにも対応できる指針を得ることができるでしょう。</p>

<p>その他にも Backbone.js を拡張するライブラリは大量に存在します。 JavaScript のライブラリ管理ツールである bower で backbone という単語で検索してみましょう。数え切れないぐらいヒットします。気になるライブラリがあったら試してみると良いでしょう。特に以下のライブラリが有名な所だと思います。</p>

<ul>
  <li>backbone-relational (モデル同士の関連を定義する機能を提供する)</li>
  <li>backbone-validation (モデルの典型的なバリデーションの定義を簡単に行う機能を提供する)</li>
  <li>backbone.stickit (データバインディング)</li>
  <li>backbone.localStorage (localStorage にモデルのデータを保存する)</li>
  <li>backbone.paginator (ビューのページネーション機能を提供する)</li>
  <li>backbone-forms (モデルと紐付いたフォームを生成する)</li>
</ul>

<h3 id="rails-開発における-javascript-のテストについて">Rails 開発における JavaScript のテストについて</h3>

<p>最後に、 Backbone.js と直接関係ありませんが、 Rails で JavaScript の単体テストを書くための環境の整え方を紹介しておきましょう。
Backbone.js 等の JavaScript のフレームワークを利用するようになると、 JavaScript の単体テストを書きたくなる機会も増えてくると思います。</p>

<p>Rails で JavaScript を書く時は、アセットパイプラインの機能を利用して CoffeeScript を記述する場合が多いと思います。しかし、 CoffeeScript をそのままテストすることはできないため、一旦アセットパイプラインを通してコンパイルしたものに対して、テストを実行する必要があります。</p>

<p>そういった処理を助けてくれる gem がいくつかあります。</p>

<ul>
  <li><a href="https://github.com/modeset/teaspoon">teaspoon</a></li>
  <li><a href="https://github.com/jfirebaugh/konacha">konacha</a></li>
  <li><a href="https://github.com/searls/jasmine-rails">jasmine-rails</a></li>
</ul>

<p>これらの gem は概ね似たような動作をします。実行すると、テスト用に Rails のサーバープロセス自体を立ち上げてアセットパイプラインにアクセスできるようにした上で、ヘッドレスブラウザや Selenium を利用して起動済みのサーバープロセスにアクセスし、そこでテスト用のスクリプトを読み込みます。
また、自分が普段利用しているブラウザからテストを実行するためのエンドポイントも用意してくれます。</p>

<p>ちなみに、 konacha は mocha というテスティングフレームワークと chai というアサーションライブラリを利用します。 jasmine-rails は jasmine を利用します。 teaspoon は mocha と jasmine と qunit を切り替えて利用できます。</p>

<p>最近の私は、比較的フレームワーク選択の自由度が高い teaspoon を利用しています。</p>

<p>今回のサンプルアプリケーションでは teaspoon を利用して記述したテストコードも同梱しているので参考にしてみてください。</p>

<h2 id="著者について">著者について</h2>

<h3 id="橋立-友宏-joker1007">橋立 友宏 (<a href="https://twitter.com/joker1007">@joker1007</a>)</h3>

<p>(株) ウサギィ所属の Rails プログラマー。Rails を利用した中小規模の受託開発を中心に仕事をしている。最近は Rails 以外にも JavaScript や Scala を書く機会が多くなってきた。『<a href="../../articles/0043/0043-BookPerfectRuby.html">パーフェクト Ruby</a>』の著者の一人。</p>


                    </div>
                </div>
            </div>
        </div>
    </div>
  </body>
</html>
