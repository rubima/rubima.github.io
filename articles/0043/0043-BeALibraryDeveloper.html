<!DOCTYPE html>
<html>
  



  <head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-41117431-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-41117431-1');
  </script>
  <script src="../../js/gtag.js"></script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ライブラリー開発者になろう</title>
  <meta name="description" content="">

  <script src="../../js/jquery.min.js"></script>
  <script src="../../js/bootstrap.min.js"></script>
  <link href="../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../../css/theme.css" rel="stylesheet" type="text/css">
  <link href="../../css/syntax.css" rel="stylesheet" type="text/css">
  <link href="../../css/sharebutton.css" rel="stylesheet" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="https://magazine.rubyist.net/articles/0043/0043-BeALibraryDeveloper.html">
  <link rel="alternate" type="application/rss+xml" title="Rubyist Magazine" href="https://magazine.rubyist.net/feed.xml">
  <link rel="shortcut icon" href="../../images/favicon.ico">
</head>

  <body>
    <div class="container-fluid">
        <div class="row full">
            <div class="col-md-2 hidden-xs sidebar">
                <h4>

</h4>

<h4>バックナンバー</h4>
<ul>
    <li><a href="../../articles/backnumber/backnumber.html">記事単位</a></li>
    <hr>
    
        <li><a href="../../articles/0061/0061-index.html">0061号(2020-02)</a></li>
    
        <li><a href="../../articles/0060/0060-index.html">0060号(2019-08)</a></li>
    
        <li><a href="../../articles/prerubykaigi2019/preRubyKaigi2019-index.html">RubyKaigi 2019 直前特集号</a></li>
    
        <li><a href="../../articles/0059/0059-index.html">0059号(2019-01)</a></li>
    
        <li><a href="../../articles/0058/0058-index.html">0058号(2018-08)</a></li>
    
        <li><a href="../../articles/prerubykaigi2018/preRubyKaigi2018-index.html">RubyKaigi 2018 直前特集号</a></li>
    
        <li><a href="../../articles/0057/0057-index.html">0057号(2018-02)</a></li>
    
        <li><a href="../../articles/prerubykaigi2017/preRubyKaigi2017-index.html">RubyKaigi 2017 直前特集号</a></li>
    
        <li><a href="../../articles/0056/0056-index.html">0056号(2017-08)</a></li>
    
        <li><a href="../../articles/0055/0055-index.html">0055号(2017-03)</a></li>
    
        <li><a href="../../articles/0054/0054-index.html">0054号(2016-08)</a></li>
    
        <li><a href="../../articles/pretokyorubykaigi11/preTokyoRubyKaigi11-index.html">東京 Ruby 会議 11 直前特集号</a></li>
    
        <li><a href="../../articles/0053/0053-index.html">0053号(2016-04)</a></li>
    
        <li><a href="../../articles/0052/0052-index.html">0052号(2015-12)</a></li>
    
        <li><a href="../../articles/0051/0051-index.html">0051号(2015-09)</a></li>
    
        <li><a href="../../articles/0050/0050-index.html">0050号(2015-05)</a></li>
    
        <li><a href="../../articles/0049/0049-index.html">0049号(2014-12)</a></li>
    
        <li><a href="../../articles/0048/0048-index.html">0048号(2014-09)</a></li>
    
        <li><a href="../../articles/0047/0047-index.html">0047号(2014-06)</a></li>
    
        <li><a href="../../articles/0046/0046-index.html">0046号(2014-04)</a></li>
    
        <li><a href="../../articles/0045/0045-index.html">0045号(2013-12)</a></li>
    
        <li><a href="../../articles/0044/0044-index.html">0044号(2013-09)</a></li>
    
        <li><a href="../../articles/0043/0043-index.html">0043号(2013-07)</a></li>
    
        <li><a href="../../articles/0042/0042-index.html">0042号(2013-05)</a></li>
    
        <li><a href="../../articles/ruby200specialen/Ruby200SpecialEn-index.html">2.0.0 Special (EN)</a></li>
    
        <li><a href="../../articles/0041/0041-index.html">0041号(2013-02)</a></li>
    
        <li><a href="../../articles/0040/0040-index.html">0040号(2012-11)</a></li>
    
        <li><a href="../../articles/0039/0039-index.html">0039号(2012-09)</a></li>
    
        <li><a href="../../articles/rubykaja/kaja.html">RubyKaja のご紹介</a></li>
    
        <li><a href="../../articles/0038/0038-index.html">0038号(2012-05)</a></li>
    
        <li><a href="../../articles/0037/0037-index.html">0037号(2012-02)</a></li>
    
        <li><a href="../../articles/0036/0036-index.html">0036号(2011-11)</a></li>
    
        <li><a href="../../articles/0035/0035-index.html">0035号(2011-09)</a></li>
    
        <li><a href="../../articles/prerubykaigi2011/preRubyKaigi2011-index.html">RubyKaigi2011直前特集号</a></li>
    
        <li><a href="../../articles/0034/0034-index.html">0034号(2011-06)</a></li>
    
        <li><a href="../../articles/0033/0033-index.html">0033号(2011-04)</a></li>
    
        <li><a href="../../articles/0032/0032-index.html">0032号(2011-01)</a></li>
    
        <li><a href="../../articles/0031/0031-index.html">0031号(2010-10)</a></li>
    
        <li><a href="../../articles/prerubykaigi2010/preRubyKaigi2010-index.html">RubyKaigi2010直前特集号</a></li>
    
        <li><a href="../../articles/0030/0030-index.html">0030号(2010-06)</a></li>
    
        <li><a href="../../articles/0029/0029-index.html">0029号(2010-03)</a></li>
    
        <li><a href="../../articles/0028/0028-index.html">0028号(2009-12)</a></li>
    
        <li><a href="../../articles/0027/0027-index.html">0027号(2009-09)</a></li>
    
        <li><a href="../../articles/0026/0026-index.html">0026号(2009-06)</a></li>
    
        <li><a href="../../articles/0025/0025-index.html">0025号(2009-02)</a></li>
    
        <li><a href="../../articles/0024/0024-index.html">0024号(2008-10)</a></li>
    
        <li><a href="../../articles/0023/0023-index.html">0023号(2008-03)</a></li>
    
        <li><a href="../../articles/0022/0022-index.html">0022号(2007-12)</a></li>
    
        <li><a href="../../articles/0021/0021-index.html">0021号(2007-09)</a></li>
    
        <li><a href="../../articles/0020/0020-index.html">0020号(2007-08)</a></li>
    
        <li><a href="../../articles/0019/0019-index.html">0019号(2007-05)</a></li>
    
        <li><a href="../../articles/0018/0018-index.html">0018号(2007-02)</a></li>
    
        <li><a href="../../articles/0017/0017-index.html">0017号(2006-11)</a></li>
    
        <li><a href="../../articles/0016/0016-index.html">0016号(2006-09)</a></li>
    
        <li><a href="../../articles/0015/0015-index.html">0015号(2006-07)</a></li>
    
        <li><a href="../../articles/rubykaigi2006/RubyKaigi2006-index.html">日本 Ruby カンファレンス 2006 特別号</a></li>
    
        <li><a href="../../articles/0014/0014-index.html">0014号(2006-05)</a></li>
    
        <li><a href="../../articles/0013/0013-index.html">0013号(2006-02)</a></li>
    
        <li><a href="../../articles/0012/0012-index.html">0012号(2005-12)</a></li>
    
        <li><a href="../../articles/0011/0011-index.html">0011号(2005-11)</a></li>
    
        <li><a href="../../articles/0010/0010-index.html">0010号(2005-10)</a></li>
    
        <li><a href="../../articles/0009/0009-index.html">0009号(2005-09)</a></li>
    
        <li><a href="../../articles/0008/0008-index.html">0008号(2005-07)</a></li>
    
        <li><a href="../../articles/0007/0007-index.html">0007号(2005-06)</a></li>
    
        <li><a href="../../articles/0006/0006-index.html">0006号(2005-05)</a></li>
    
        <li><a href="../../articles/0005/0005-index.html">0005号(2005-02)</a></li>
    
        <li><a href="../../articles/0004/0004-index.html">0004号(2004-12)</a></li>
    
        <li><a href="../../articles/0003/0003-index.html">0003号(2004-11)</a></li>
    
        <li><a href="../../articles/0002/0002-index.html">0002号(2004-10)</a></li>
    
        <li><a href="../../articles/0001/0001-index.html">0001号(2004-09)</a></li>
    
</ul>
<p class="rss-subscribe"><a href="/feed.xml">RSS</a></p>

            </div>
            <div class="col-md-10 main">
                <div class="row">
                    <div class="col-md-12">
                        <img src="../../images/rubima_logo_l.png">
                        <h1>ライブラリー開発者になろう</h1>
                        <div class="social-buttons">
                            <div class='sns'>            
    <ul class="clearfix">
       <li class="twitter"><a href="https://twitter.com/share?text=ライブラリー開発者になろう&amp;url=https://magazine.rubyist.net/articles/0043/0043-BeALibraryDeveloper.html" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa fa-twitter"></i></a></li>
       <li class="facebook"><a href="https://www.facebook.com/sharer.php?u=https://magazine.rubyist.net/articles/0043/0043-BeALibraryDeveloper.html&amp;t=ライブラリー開発者になろう" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa fa-facebook"></i></a></li>
       <li class="hatebu"><a href="http://b.hatena.ne.jp/add?mode=confirm&amp;url=https://magazine.rubyist.net/articles/0043/0043-BeALibraryDeveloper.html&amp;ライブラリー開発者になろう" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa">B!</i></a></li>
    </ul>
</div>
                        </div>
                        <div class="post_info">
                            



                        </div>
                        
<ul id="markdown-toc">
  <li><a href="#ライブラリー開発者になろう" id="markdown-toc-ライブラリー開発者になろう">ライブラリー開発者になろう</a>    <ul>
      <li><a href="#はじめに" id="markdown-toc-はじめに">はじめに</a></li>
    </ul>
  </li>
  <li><a href="#" id="markdown-toc-"><img src="../../images/0043-BeALibraryDeveloper/slide-title.png" alt="slide-title.png" /></a>    <ul>
      <li><a href="#よいソフトウェアとはどんなソフトウェアか" id="markdown-toc-よいソフトウェアとはどんなソフトウェアか">よいソフトウェアとはどんなソフトウェアか</a>        <ul>
          <li><a href="#api-を考えてみる" id="markdown-toc-api-を考えてみる">API を考えてみる</a></li>
          <li><a href="#補足-fileopen-と-kernelopen" id="markdown-toc-補足-fileopen-と-kernelopen">補足: <em>File.open</em> と <em>Kernel.#open</em></a></li>
          <li><a href="#ruby-らしいブロックの使い方" id="markdown-toc-ruby-らしいブロックの使い方">Ruby らしいブロックの使い方</a></li>
          <li><a href="#おさらい" id="markdown-toc-おさらい">おさらい</a></li>
        </ul>
      </li>
      <li><a href="#キーとなる考え" id="markdown-toc-キーとなる考え">キーとなる考え</a></li>
    </ul>
  </li>
  <li><a href="#-1" id="markdown-toc--1"><img src="../../images/0043-BeALibraryDeveloper/remember-than-imagine.png" alt="remember-than-imagine.png" /></a></li>
  <li><a href="#-2" id="markdown-toc--2"><img src="../../images/0043-BeALibraryDeveloper/how-to-get-knowledge.png" alt="how-to-get-knowledge.png" /></a>    <ul>
      <li><a href="#キーとなる考えを適用する" id="markdown-toc-キーとなる考えを適用する">キーとなる考えを適用する</a></li>
    </ul>
  </li>
  <li><a href="#-3" id="markdown-toc--3"><img src="../../images/0043-BeALibraryDeveloper/apply-the-key-idea.png" alt="apply-the-key-idea.png" /></a></li>
  <li><a href="#-4" id="markdown-toc--4"><img src="../../images/0043-BeALibraryDeveloper/what-experience-is-needed-for-knowledge.png" alt="what-experience-is-needed-for-knowledge.png" /></a></li>
  <li><a href="#-5" id="markdown-toc--5"><img src="../../images/0043-BeALibraryDeveloper/rubyist-experience-is-needed-for-knowledge.png" alt="rubyist-experience-is-needed-for-knowledge.png" /></a>    <ul>
      <li><a href="#練習-1-プロパティーの値を取得する-api" id="markdown-toc-練習-1-プロパティーの値を取得する-api">練習 1: プロパティーの値を取得する API</a></li>
      <li><a href="#補足-メソッド名に使えないプロパティー名はないの" id="markdown-toc-補足-メソッド名に使えないプロパティー名はないの">補足: メソッド名に使えないプロパティー名はないの？</a></li>
      <li><a href="#思い出すことは難しい" id="markdown-toc-思い出すことは難しい">思い出すことは難しい</a></li>
    </ul>
  </li>
  <li><a href="#-6" id="markdown-toc--6"><img src="../../images/0043-BeALibraryDeveloper/remember-is-difficult.png" alt="remember-is-difficult.png" /></a></li>
  <li><a href="#-7" id="markdown-toc--7"><img src="../../images/0043-BeALibraryDeveloper/no-remember-experience.png" alt="no-remember-experience.png" /></a></li>
  <li><a href="#-8" id="markdown-toc--8"><img src="../../images/0043-BeALibraryDeveloper/library-developer-experience-is-useful.png" alt="library-developer-experience-is-useful.png" /></a>    <ul>
      <li><a href="#練習-2-真偽値を返すメソッド" id="markdown-toc-練習-2-真偽値を返すメソッド">練習 2: 真偽値を返すメソッド</a></li>
      <li><a href="#練習-3-なんでもメソッドにすれば-ruby-らしいか" id="markdown-toc-練習-3-なんでもメソッドにすれば-ruby-らしいか">練習 3: なんでもメソッドにすれば Ruby らしいか</a></li>
      <li><a href="#練習-4-明示的な初期化が必要なライブラリー" id="markdown-toc-練習-4-明示的な初期化が必要なライブラリー">練習 4: 明示的な初期化が必要なライブラリー</a></li>
      <li><a href="#練習-5-インストールドキュメント" id="markdown-toc-練習-5-インストールドキュメント">練習 5: インストールドキュメント</a></li>
      <li><a href="#補足-システムのパッケージを自動インストールすることはやり過ぎか" id="markdown-toc-補足-システムのパッケージを自動インストールすることはやり過ぎか">補足: システムのパッケージを自動インストールすることはやり過ぎか</a></li>
      <li><a href="#補足-どうやってシステムのパッケージを自動インストールする方法を思いつくか" id="markdown-toc-補足-どうやってシステムのパッケージを自動インストールする方法を思いつくか">補足: どうやってシステムのパッケージを自動インストールする方法を思いつくか</a></li>
      <li><a href="#おさらい-1" id="markdown-toc-おさらい-1">おさらい</a></li>
      <li><a href="#まとめ" id="markdown-toc-まとめ">まとめ</a></li>
    </ul>
  </li>
  <li><a href="#著者紹介" id="markdown-toc-著者紹介">著者紹介</a></li>
</ul>

<p>書いた人: 須藤 功平 (<a href="https://github.com/kou">kou</a>)</p>

<h2 id="ライブラリー開発者になろう">ライブラリー開発者になろう</h2>

<p>この記事は <a href="http://rubykaigi.org/2013">RubyKaigi 2013</a> の 3 日目の午後に私がした発表 <a href="http://rubykaigi.org/2013/talk/S94">Be a library developer!</a> に関する記事です。発表のまとめに加えてたくさんの補足を詰め込んでいます。</p>

<p>発表資料や当日の動画は以下にあります。発表内容だけで十分という方はこれらを参考にしてください。</p>

<p>発表資料は以下にあります。どのサイトにも同じ PDF をアップロードしているので見やすいサイトを選んでください。</p>

<ul>
  <li><a href="http://slideshare.net/kou/rubykaigi-2013">SlideShare</a></li>
  <li><a href="http://speakerdeck.com/u/kou/p/be-a-library-developer">Speaker Deck</a></li>
  <li><a href="http://slide.rabbit-shocker.org/authors/kou/rubykaigi-2013/">Rabbit Slide Show</a></li>
</ul>

<p>発表資料のソースは GitHub にあります。</p>

<ul>
  <li><a href="https://github.com/kou/rabbit-slide-kou-rubykaigi-2013">https://github.com/kou/rabbit-slide-kou-rubykaigi-2013</a></li>
</ul>

<p>当日の動画は以下にあります。どちらも同じ動画です。</p>

<ul>
  <li><a href="http://www.ustream.tv/recorded/33615831">Ustream</a></li>
  <li><a href="http://vimeo.com/69128203">Vimeo</a></li>
</ul>

<p>なお、この記事は資料を見なくてもわかるようにまとめています。まとめの合間に何度か長めの補足が入っています。補足のセクションのタイトルには「補足:」と入れているので、まとめだけで十分という方は「補足:」と入っているセクションを飛ばしてください</p>

<h3 id="はじめに">はじめに</h3>

<p>この発表ではよいソフトウェアを開発する方法を 1 つ紹介しました。この方法は私の経験をベースとしています。</p>

<p>私がソフトウェアを書き始めてから 10 数年経ちました。書き始めた頃から書いたコードのほとんどをフリーソフトウェアとして公開しているので、たまに昔のコードを読む機会があります。そのとき、数年前よりも今の方がよいコードを書けるようになっていることに気づきます。この発表は、どうして自分は昔よりもよいコードを書けるようになっているのかをふりかえって得られた知見をまとめたものです。この知見がよいコードを書きたいと思っている人の参考になればよいなぁと思って発表しました。</p>

<p>この発表で伝えた「よいソフトウェアを開発する方法」は「ライブラリー開発者になること」です。どうしてこの方法につながるのか。キーとなる考えは「想像するよりも思い出す」です。</p>

<h2><a href="http://slide.rabbit-shocker.org/authors/kou/rubykaigi-2013/"><img src="../../images/0043-BeALibraryDeveloper/slide-title.png" alt="slide-title.png" /></a></h2>

<h3 id="よいソフトウェアとはどんなソフトウェアか">よいソフトウェアとはどんなソフトウェアか</h3>

<p>「よいソフトウェアを開発する方法」について考える前に、まずは「よいソフトウェア」について考えてみましょう。</p>

<h4 id="api-を考えてみる">API を考えてみる</h4>

<p>こんな API について考えてみましょう。これは <a href="https://rubygems.org/gems/cairo">cairo gem</a> というグラフィックスライブラリーの API です。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> context.save
 context.circle(50, 50, 10)
 context.stroke
 context.restore</code></pre></figure>

<p>このコードは、<em>save</em> で現在の描画情報を保存し、<em>restore</em> で保存した状態まで戻しています。<em>save</em> と <em>restore</em> の間で <em>circle</em> と <em>stroke</em> を使って円を描いています。円を描くために変更された描画情報は <em>restore</em> のところで元に戻ります<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。</p>

<p>では、このコードよりもよいコードで書けるようにするために API を改良できないか考えてみましょう。より「よい」の基準はいくつもあります。まずは自分のより「よい」の基準で考えてみてください。</p>

<p>考えましたか？</p>

<p>例えば、<em>save</em> と <em>restore</em> に注目してみるとどうでしょうか。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> context.save      # ← 注目
 context.circle(50, 50, 10)
 context.stroke
 context.restore   # ← 注目</code></pre></figure>

<p>ここに注目するとブロックを使った書き方を思いつきます。こちらの方がよりよい API です。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> context.save do
   context.circle(50, 50, 10)
   context.stroke
 end</code></pre></figure>

<p>では、どうしてブロックを使ったほうがよりよい API なのでしょうか。それはより Ruby らしい書き方だからです。</p>

<p>「Ruby らしい」とはどういうことでしょうか。「○○らしい」とは「他と似ている」ということです。「Ruby らしい」書き方だとまわりのコードと似たような記述になります。つまり、まわりのコードと統一感がでるということです。統一感がでると読みやすくなります。読みやすくなるとメンテナンスが楽になります。いきなりよいソフトウェアを作ることは難しいため、繰り返し繰り返し継続してソフトウェアを開発していく方法が現実的です。メンテナンスが楽になると開発を継続しやすくなり、よりよいソフトウェアにつながります。</p>

<p>つまり、「Ruby らしい書き方」にするとよりよいソフトウェアにつながるため、「Ruby らしい書き方」はよりよい基準のひとつと言えます。</p>

<p>では、このブロックの使い方は「Ruby らしい」のでしょうか。File クラスを思い出してください。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> file = File.open(path) # 前処理
 file.read
 file.close             # 後処理</code></pre></figure>

<p>まず <em>open</em> でファイルを開きます。これは前処理です。<em>read</em> して使い終わったら閉じます。これは後処理です。</p>

<h4 id="補足-fileopen-と-kernelopen">補足: <em>File.open</em> と <em>Kernel.#open</em></h4>

<p>(最初の補足です。)</p>

<p>ところで、これを見て <em>File.open</em> ではなく <em>Kernel.#open</em> を使ったほうがよいと思う人もいることでしょう。理由は「記述が短い」や「ファイル以外にも対応できる」あたりでしょうか。しかし、私は <em>File.open</em> を使ったほうがよいと考えています。理由は「ファイルを開くことが明確なコードになるから」です。ファイルしか扱わない場所ではファイルしか扱わない API を使うことでコードで表現したい意図が明確になります。一方、ファイル以外にも様々な入力を受け付けたい場合は <em>Kernel.#open</em> を使います。</p>

<p>この考えは <em>end_with?</em><sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> と <em>/\z/</em><sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup> の使い分けにも応用が効きます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> def ruby_script?(path)
   path.end_with?(".rb")
 end</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> def ruby_script?(path)
   /\.rb\z/ =~ path
 end</code></pre></figure>

<p><em>end_with?</em> を使っているコードは「パスが .rb で終わっているなら Ruby スクリプト」と読めます。<em>/\z/</em> を使っているコードは「パスが .rb で終わるパターンにマッチするなら Ruby スクリプト」と読めます。<em>end_with?</em> の方がやりたいことそのものに読めます。</p>

<p>この補足では、より多くのことができる機能よりもやりたいことそのものの機能があるなら、そのものの機能を使ったほうがやりたいことの意図を明確に伝えられるコードになるという例を示しました。</p>

<p>補足は長かったでしょうか？　これから出てくる補足もこのくらいの長さになります。</p>

<h4 id="ruby-らしいブロックの使い方">Ruby らしいブロックの使い方</h4>

<p>話を戻します。こんなコードを考えていたのでした。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> file = File.open(path) # 前処理
 file.read
 file.close             # 後処理</code></pre></figure>

<p>このように明示的に <em>close</em> を書くのは Ruby 初心者です。Ruby に慣れた人はこのようにブロックを使って書きます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> File.open(path) do |file| # 前処理
   file.read
 end                       # 後処理</code></pre></figure>

<p>こうすることの利点は 2 つです。1 つは <em>close</em> のし忘れがなくなるということです。もう 1 つは後処理の詳細を意識しなくてよくなるということです。ファイルの場合の後処理は <em>close</em> で、<em>Dir.chdir</em> のときは元のディレクトリーに戻る、などと使いわける必要はありません。ブロックを抜けたら「いい感じ」に後処理をしてくれます。これが Ruby の組み込みライブラリーで使われている後処理のためにブロックを使う方法です。つまり、これと「似た」使い方をすれば「Ruby らしい」ということです。</p>

<p>では、もう一度 cairo gem の例を見てみましょう。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> context.save do # 前処理
   context.circle(50, 50, 10)
   context.stroke
 end             # 後処理</code></pre></figure>

<p><em>save</em> が前処理の部分、ブロックを抜けたところで実行する <em>restore</em> は後処理の部分です。<em>File</em> と「似た」使い方ですね。ということでこの API は「Ruby らしい」といえます。</p>

<h4 id="おさらい">おさらい</h4>

<p>おさらいします。</p>

<p>「よいソフトウェアを開発する方法」について考える前に、まずは「よいソフトウェア」について考えました。「よい」の基準の 1 つは「Ruby らしい」です。「Ruby らしい」を言いかえると「他と似ている」なので、「よい」を「他と似ている」と言いかえることができます。つまり、「よいソフトウェアを開発する方法」は「似ているとはどういうことかを知って、それと同じようにすること」と言いかえることができます。</p>

<p>それでは、「似ているとはどういうことかを知って、それと同じようにすること」を実現するにはどうしたらよいか考えてみましょう。</p>

<h3 id="キーとなる考え">キーとなる考え</h3>

<p>まず、「似ているとはどういうことかを知って、それと同じようにすること」を実現するためのキーとなる考えを説明します。</p>

<p>キーとなる考えは、「想像するよりも思い出す」です。</p>

<h2 id="-1"><img src="../../images/0043-BeALibraryDeveloper/remember-than-imagine.png" alt="remember-than-imagine.png" /></h2>
<p>「想像すること」は難しいことです。これはまだ知らないことを思いつかなければいけないからです。0 から 1 にすることは難しいことです。</p>

<p>では、「思い出すこと」はどうでしょうか。これは、想像することに比べれば簡単なことです。なぜなら、すでに知っていることの中から適切なことを選んでくるだけだからです。新しく思いつく必要はありません。すでにある 0 から 9 の中から一番よさそうな数 (例えば 7 とか) を選んでくるようなものです。</p>

<p>また、知っていることから選ぶ場合は、それを選んだ「結果」もわかる場合があります。「よい結果」とわかっていることを選んだ場合は、今回もうまくいく可能性が高くなります。</p>

<p>思い出せるようになるには知っている必要があります。では、どうやって知ればよいでしょう。</p>

<h2 id="-2"><img src="../../images/0043-BeALibraryDeveloper/how-to-get-knowledge.png" alt="how-to-get-knowledge.png" /></h2>
<p>知るためには自分で経験する方法、人から聞く方法、観察して学ぶ方法などがあります。この中でも一番初めにやることは経験してみることです。経験すれば知っているので思い出せるようになります。</p>

<p>ということで、キーとなる考えは「想像するよりも思い出す」です。</p>

<h3 id="キーとなる考えを適用する">キーとなる考えを適用する</h3>

<p>それでは、「よいソフトウェアを開発する」ために「想像するよりも思い出す」というキーとなる考えを適用してみましょう。</p>

<h2 id="-3"><img src="../../images/0043-BeALibraryDeveloper/apply-the-key-idea.png" alt="apply-the-key-idea.png" /></h2>
<p>「よいソフトウェアを開発する」には、「似ているとはどういうことかを知って、それと同じようにする」とよいのでした。それでは、「似ているとはどういうことかを知る」ために何を経験すればよいでしょうか。</p>

<h2 id="-4"><img src="../../images/0043-BeALibraryDeveloper/what-experience-is-needed-for-knowledge.png" alt="what-experience-is-needed-for-knowledge.png" /></h2>
<p>それは「Rubyist」としての経験です。組み込みライブラリーや標準添付のライブラリーを何度も使っていればどのような API があるのかわかってきます。どのような API があるか知っていくと同じような使い方の API が見えてきます。○○の API が他の××の API と同じように使えたならそれらは似ています。例えば、<em>File.open</em> と <em>Dir.open</em> はどちらも同じように使えます。ブロックを受け取り、ブロックにファイル・ディレクトリーを渡し、ブロックの処理が終わったらファイル・ディレクトリーを <em>close</em> します。</p>

<h2 id="-5"><img src="../../images/0043-BeALibraryDeveloper/rubyist-experience-is-needed-for-knowledge.png" alt="rubyist-experience-is-needed-for-knowledge.png" /></h2>

<h4 id="練習-1-プロパティーの値を取得する-api">練習 1: プロパティーの値を取得する API</h4>

<p>これを読んでいる人であればある程度 Rubyist としての経験があるでしょう。それでは実際に Rubyist としての経験を活かして練習してみましょう。以下のコードを考えてみます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> window.get_property("opacity")
 # よりよい API は？？？</code></pre></figure>

<p>これは <a href="https://rubygems.org/gems/gtk2/">gtk2 gem</a> という GUI ライブラリーの API です。<em>window</em> オブジェクトの <em>opacity</em> プロパティーの値を取得しています。では、これをどうすればよりよい API になるか考えてみてください。この話の中では「Ruby らしい」かどうかをより「よい」の基準としていました。どうすればより Ruby らしい API になるでしょうか。</p>

<p>考えましたか？</p>

<p>以下のように「プロパティーの値を返す、プロパティーと同じ名前のメソッド」の方が Ruby らしい API、つまりよりよい API です。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> window.get_property("opacity")
 window.opacity # よりよい API</code></pre></figure>

<p>オブジェクトのプロパティーを取得するためにプロパティーと同じ名前のメソッドを使うというのは Ruby ではよくやる方法なので、この方法は Ruby らしいです。プロパティーを属性と言いかえるとわかりやすいでしょう。Ruby には <em>attr_reader</em> という「属性の値を返す、属性と同じ名前のメソッド」を定義する、そのためのショートカットが用意されています。</p>

<h4 id="補足-メソッド名に使えないプロパティー名はないの">補足: メソッド名に使えないプロパティー名はないの？</h4>

<p>発表時には触れなかったことについて補足します<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>。</p>

<p>gtk2 gem は <a href="http://www.gtk.org/">GTK+</a> という GUI ライブラリーを Ruby から使えるようにしたライブラリーです。そのため、プロパティー名は GTK+ の規則に従います。プロパティー名として Ruby のメソッド名で使えない文字が使われていないか気になるところです。実はプロパティー名には「-」も使うことができます<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup>。これだけが Ruby のメソッド名では使えない文字です。ただし、プロパティー名として「-」の代わりに「_」を使っても GTK+ 内部<sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup>で「-」に正規化するため、gtk2 gem で「default-height」プロパティー用のメソッド名として「default_height」を使えば、Ruby から見ても GTK+ から見ても問題も違和感もありません。</p>

<p>なお、仮にどうしても使えない文字があった場合はどうしますか？　私ならそのプロパティー用のメソッドは用意せず、用意できるものだけ用意します。メソッドを用意できないプロパティーはそもそも Ruby らしくない名前なので Ruby の属性と似せることはできません。</p>

<p>では、<em>window[“default-height”]</em><sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup>のように取得できるようにするのはどうでしょうか。これについてはもう少し後の補足で触れます。そこでは <em>[]</em> を使うときはどんなときかを考えます。</p>

<p>なお、Ruby のメソッド名として使えないプロパティー名の値は <em>get_property</em> を使えば取得できるので、Ruby らしさから外れたものはそれらを使うという割り切りはアリです。ただし、これは多くのプロパティー名が Ruby のメソッド名としても使える場合に限ります。多くのプロパティー名が Ruby のメソッド名として使えない場合はプロパティーと Ruby の属性は似ていないということです。無理やり Ruby の属性と似せようとしてはいけません。思い出すものを間違っています。</p>

<p>補足はここまでです。</p>

<h4 id="思い出すことは難しい">思い出すことは難しい</h4>

<p>ところで、<em>get_property</em> のよりよい API を考えられましたか？　「思い出す」というのは意外と「難しい」と思いませんでしたか？<sup id="fnref:8"><a href="#fn:8" class="footnote">8</a></sup>　そう、難しいんです。「思い出せ！？」「Ruby らしいって何！？」そう思ったことでしょう。</p>

<h2 id="-6"><img src="../../images/0043-BeALibraryDeveloper/remember-is-difficult.png" alt="remember-is-difficult.png" /></h2>
<p>すでに知っているはずなのにどうして思い出すことが難しいのでしょう。それは、「想像するよりも思い出す」という経験をしていないからです。今のあなたの状態は「経験した」という状態ではなく、「読んだだけ」という状態です。</p>

<h2 id="-7"><img src="../../images/0043-BeALibraryDeveloper/no-remember-experience.png" alt="no-remember-experience.png" /></h2>
<p>それでは、もう一度。「よいソフトウェアを開発する」、「似ているとはどういうことかを知って、それと同じようにする」を実現するためには何を経験したらよいのでしょうか。それは、ライブラリー開発者としての経験です。ここでようやくこの話のタイトルがでてきました。</p>

<h2 id="-8"><img src="../../images/0043-BeALibraryDeveloper/library-developer-experience-is-useful.png" alt="library-developer-experience-is-useful.png" /></h2>
<p>ライブラリー開発者は Rubyist として使いやすい API とはどういう API だろうと考えたり、ライブラリーのユーザーとしてわかりやすいドキュメントはどんなドキュメントだろうと考えたりします。他にもいろいろ考えます。そして、これらを何度も何度もたくさん考えます。考える機会がたくさんあるのです。「たくさん」というのはとてもよい練習になります。そのため、「想像するよりも思い出す」をうまくやるためにはライブラリー開発者になることをオススメします。</p>

<p>それではいくつか練習してみましょう。</p>

<h4 id="練習-2-真偽値を返すメソッド">練習 2: 真偽値を返すメソッド</h4>

<p>まずは簡単な練習です。プロパティーの値を取得するには以下のようにプロパティー名と同じ名前のメソッドを用意するのが Ruby らしいのでした。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> # 低レベルな API
 window.get_property("opacity")
 # よりよい API
 window.opacity</code></pre></figure>

<p>それでは、<em>visible</em> というプロパティーの場合はどうでしょう。ヒントは <em>visible</em> は真偽値を返すということです。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> # 低レベルな API
 window.get_property("visible")
 # よりよい API は？
 # ???: ヒント: "visible" は真偽値を返す</code></pre></figure>

<p>考えましたか？</p>

<p>Ruby らしくするならメソッド名の最後に「<em>?</em>」をつけます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> # 低レベルな API
 window.get_property("visible")
 # よりよい API
 window.visible?</code></pre></figure>

<h4 id="練習-3-なんでもメソッドにすれば-ruby-らしいか">練習 3: なんでもメソッドにすれば Ruby らしいか</h4>

<p>では、なんでもメソッドにすればよいのでしょうか。この例ではどうでしょう。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> # レコードを「コレクション」と考えるならよりよい API
 record["name"]
 # レコードを「オブジェクト」と考えるならよりよい API
 record.name</code></pre></figure>

<p>ここの <em>record</em> はテーブルの中の 1 つのレコードです。このレコードのカラムの値にアクセスすることを考えます。<em>Hash</em> のようにアクセスする方法とメソッドでアクセスする方法ではどちらがよいでしょうか。レコードをカラムが集まったコレクションと考えるなら <em>Hash</em> のようにアクセスする方法が Ruby らしいですし、オブジェクトと考えるならメソッドでアクセスする方法が Ruby らしいです。</p>

<p>さて、それでは GUI のウィジェットであるウィンドウはプロパティーが集まったコレクションと考えられるでしょうか。ウィンドウの主要な機能はプロパティーの操作ではなく GUI 関連の機能です。そのため、コレクションと考えるよりもオブジェクトと考える方が妥当です。よって、プロパティーにアクセスするために <em>[]</em> を使うのは Ruby らしくありません<sup id="fnref:9"><a href="#fn:9" class="footnote">9</a></sup>。</p>

<h4 id="練習-4-明示的な初期化が必要なライブラリー">練習 4: 明示的な初期化が必要なライブラリー</h4>

<p>少し難しい例も考えてみましょう。この例は発表時には省略した例です。</p>

<p>この例の <em>Gst.init</em> をよりよくできないでしょうか。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> require "gst"
 Gst.init # ← よりよくしたい
 Gst::ElementFactory.make("playbin")</code></pre></figure>

<p>通常のライブラリーは <em>require</em> すれば使えますが、この API では <em>require</em> しただけでは使えません。<em>require</em> した後に <em>Gst.init</em> を呼ぶ必要があります。</p>

<p>そもそも <em>Gst.init</em> はなんのために必要なのかというと、デバッグオプションを指定するなど高度な使い方に対応するためです。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> require "gst"
 Gst.init("--gst-debug=*:9") # ← 高度な使い方のために必要
 Gst::ElementFactory.make("playbin")</code></pre></figure>

<p>変わった使い方をしたいときに通常の使い方と変わってしまうのはしょうがありませんが、それが通常の使い方をしたいときにも影響を与えてしまっては使い勝手が悪いです。どうしたらよりよい API になるでしょうか。</p>

<p>考えましたか？</p>

<p>高度な使い方をしなくてもよいときは <em>Gst.init</em> を呼ばなくても動くようにします。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> require "gst"
 # Gst.init # ← オプションにして呼ばなくても動くようにする
 Gst::ElementFactory.make("playbin")</code></pre></figure>

<p>Ruby では <em>require</em> するだけで (明示的な初期化をせずに) すぐにライブラリーを使えるようになることが多いので、今回も <em>require</em> だけで使えるようにする、ということです。他のライブラリーの使い方に似せたということです。</p>

<p>参考までに実装方法を紹介します。ポイントは <em>const_missing</em> と <em>remove_method</em> です。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> class &lt;&lt; Gst
   def const_missing(name)
     init
     const_get(name)
   end

   def init(*argv)
     # ライブラリーを初期化
     class &lt;&lt; self
       remove_method(:const_missing)
     end
   end
 end</code></pre></figure>

<p>必要なときだけ <em>Gst.init</em> を呼べばよいという API を「思い出す」ことはできるでしょうが、どうやって実装するかは「思い出す」ことはできないでしょう。これについては、もう少し後で触れます。</p>

<h4 id="練習-5-インストールドキュメント">練習 5: インストールドキュメント</h4>

<p>次は、API ではなくドキュメントについて考えてみましょう。ソフトウェアの開発はコードを書くだけではありません。</p>

<p>これは gtk2 gem のインストールドキュメントを書いた例です。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> インストール方法：

   Debian GNU/Linux では：
     % sudo apt-get install libgtk2.0-dev
     % gem install gtk2
   OS X では：
     ...</code></pre></figure>

<p>gtk2 gem は拡張ライブラリーなので事前に GTK+ という C のライブラリーをインストールしておく必要があります。ユーザーのことを考えると、ドキュメントには「gem install gtk2 する前に GTK+ のライブラリのインストールが必要なので、OS ごとのインストール方法を書いておかないと」となります。でも、これでよいのでしょうか。よりよいドキュメントならこうするべきです。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> インストール方法：
   % gem install gtk2</code></pre></figure>

<p>gem をインストールするときは「<strong>gem install gem</strong>」が普通のやり方です。これが RubyGems らしさです。普通はこれでインストールするなら、これでインストールできるようにするべきなのです。gtk2 gem は <strong>gem install gtk2</strong> とやったら必要なパッケージを自動でインストールするようにして、インストールドキュメントは <strong>gem install gtk2</strong> だけにしています。</p>

<h4 id="補足-システムのパッケージを自動インストールすることはやり過ぎか">補足: システムのパッケージを自動インストールすることはやり過ぎか</h4>

<p>発表時には触れなかったことについて 2 つ補足します。1 つはシステムのパッケージを自動でインストールするということについてです。もう 1 つはパッケージを自動でインストールするということをどうやって思いつくかということについてです。どちらも長めの補足になります。</p>

<p>まずは、システムのパッケージを自動でインストールするということについてです。</p>

<p>gem 以外のパッケージを勝手にインストールされるのがイヤだと思った人がいるはずです。私も昔はそう思っていましたが、以下の理由から自動でインストールしたほうがよいと思うようになりました。</p>

<ul>
  <li>インストールでつまづいている人をたくさん見た</li>
  <li>セキュリティーに対する脅威は変わらない</li>
  <li>どうせ手動で同じことをやることになる</li>
</ul>

<p>最初の「インストールでつまづいている人をたくさん見た」ことが一番大きな理由です。gem をインストールしたい人が一番したいことは「使うこと」です。インストールが大変なために使う前に諦めたり、インストールできたとしてもインストールしたことに満足して使うことがどうでもよくなったりした人を見てきました。いくらよりよい API のライブラリーでも使われなければ API のよさは関係ありません。そのため、インストールでつまづかないようにすることを重視するようになりました。</p>

<p>セキュリティーについても考えました。自動でインストールすることでセキュリティーに対する脅威は増えるのか。</p>

<p>Linux 環境では <em>sudo</em> 経由でインストールコマンドを実行します。セキュリティーを重視している人は <em>sudo</em> を実行する前にパスワードを入力する設定にしているはずです。<em>sudo</em> のパスワード入力を促すプロンプトには「○○というパッケージをインストールするために <em>sudo</em> のパスワードを入力してください」とでるようにしています。つまり、セキュリティーを意識している人たちには適切に判断するタイミングと判断する材料を提供しています。そのため深刻な問題はないと考えています。もし、パスワードなしで <em>sudo</em> を実行できるようにしている場合はそれほどセキュリティーを意識していないと考えられるため、それほどケアしなくても問題ないと考えています。</p>

<p>OS X 環境で Homebrew を使っている場合は <em>sudo</em> を使わないでそのまま実行します。つまり、パッケージのインストールを確認するプロセスがありません。では、パッケージのインストールを確認するプロセスが必要なのかを考えてみましょう。</p>

<p>ユーザーは <strong>gem install …</strong> としているのでパッケージをインストールしたいという意思を示したと考えることができます。つまり、すでにインストールしたいと示したのでよきに計らうことの方がユーザーの意思を反映しているという考えです。強引でしょうか。多少強引かもしれません。</p>

<p>では、そもそも、一般ユーザー権限で <strong>gem install …</strong> することはそんなに安全なのでしょうか。ホームディレクトリーを削除する悪意のあるライブラリーをインストールして使ってしまうという危険性が考えられます。サーバー上の特定サービス用のユーザーであれば被害を最小限に抑えられるため安全と言えます。では、開発用のマシンや普段使いのマシンではどうでしょうか。/usr/ 以下を全部削除されるより、ホームディレクトリーを削除される方が被害が大きいのではないでしょうか。システムはインストールしなおせばよいですが、ホームディレクトリーは最後にバックアップしたところまでしか復旧できません。</p>

<p>このように考えると、自動でシステムにパッケージをインストールしようとしてもセキュリティーに対する脅威はそれほど変わらないと言えるでしょう。</p>

<p>自動でインストールしない場合についても考えました。自動でインストールしない場合は、使いたいなら手動でシステムにパッケージをインストールします。どうせ同じことをするのです。私は <a href="http://rubygems.org/gems/nokogiri">nokogiri gem</a> をインストールするときに、<strong>gem install nokogiri</strong> して失敗して、<strong>sudo apt-get install …</strong> して、再度 <strong>gem install nokogiri</strong> をしていました。</p>

<p>どうせ手動でパッケージをインストールするのであれば、最初から自動でインストールしても同じことです。もし、パッケージを追加でインストールすることをシビアに考えている人はインストールする前に依存しているライブラリーを調べるはずです。それらの人のためには、インストール方法のドキュメントとは別の場所に依存ライブラリーをリストアップしておくことができます<sup id="fnref:10"><a href="#fn:10" class="footnote">10</a></sup>。本当にシビアな人は調べるはずです。これは、パッケージでインストールしないで自分でビルドしてインストールする人にも当てはまります。</p>

<p>長くなりましたが、パッケージを自動でインストールするようにしても、よく考えてみれば、最初に抱くイメージほど変なことではないということです。</p>

<h4 id="補足-どうやってシステムのパッケージを自動インストールする方法を思いつくか">補足: どうやってシステムのパッケージを自動インストールする方法を思いつくか</h4>

<p>もう 1 つ補足します。これも長いです。</p>

<p>パッケージを自動でインストールするという方法をどうやって思いつくかということについてです<sup id="fnref:11"><a href="#fn:11" class="footnote">11</a></sup>。</p>

<p>パッケージを自動でインストールする方法は他のライブラリーではやっていません。そのため、知っていることを「思い出す」ということはできません。目指したい場所を思い出してみつけることはできるがそこまでの道のりは思い出すことができない、ということはよくあります。少し前の <em>Gst.init</em> を呼ばなくても済むようにしたいという例もこのケースです。</p>

<p>では、今いる場所とゴールがわかっている状態で間をどうやって埋めていけばよいのでしょうか。残念ながら私はこの問いに対する答えをまだ持っていません。それでも自分はどうやっているだろうかと思い出して説明してみます。まず、ゴールを手前に近づけようとしている気がします。アスキーアート付きで説明します。</p>

<p>最初は「今いる場所」と「ゴール」がわかっていて、間をどう埋めればよいかわからない状態です。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">   ここをどう埋めればよいかわからない
   ←ーーーーーーーーーーーーーーー→
 ○ーーーーーーーーーーーーーーーーー○
 今いる場所                         ゴール</code></pre></figure>

<p>この状態からゴールに到達するために、ゴールの少し手前にある「ここからゴールまではなんとかなりそうな場所」を探します。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> ○ーーーーーーーーーーーーー△ーーー○
 今いる場所                  ↑     ゴール
                ここからゴールまではなんとかなりそうな場所
                              ←ーー→
                              ここがなんとかなりそう</code></pre></figure>

<p>そして、「今いる場所」から「ここからゴールまではなんとかなりそうな場所」にどうやっていくかを考えます。このなんとかなりそうな場所はゴールより近いので、ゴールまでいく方法を考えるよりアイディアが浮かんできます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> ○ーーーーーーーーーーーーー△ーーー○
 今いる場所                  ↑     ゴール
                ここからゴールまではなんとかなりそうな場所
                ここまでどうやっていくかを考える</code></pre></figure>

<p>それでもダメなときは別の「ここからゴールまではなんとかなりそうな場所」を探します。一度探した「ここからゴールまではなんとかなりそうな場所」をベースにさらに近づけようとは考えていない気がします。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> ○ーーーーーーーーー☆ーーー△ーーー○
 今いる場所          ↑             ゴール
                前のなんとかなりそうな場所ベースで近づけた場所
                 (こういう考え方はしていなそう)</code></pre></figure>

<p>さて、みなさんは「今いる場所」と「ゴール」がわかっているとき、どうしているでしょうか<sup id="fnref:12"><a href="#fn:12" class="footnote">12</a></sup>。</p>

<h4 id="おさらい-1">おさらい</h4>

<p>だいぶ補足が長くなって、なんの話だったか忘れていると思うのでおさらいします。</p>

<p>実際に「想像するよりも思い出す」というキーとなる考えを適用してみることを練習をしました。Rubyist として普通はどうやっているかを「思い出す」、そしてそれと同じようにする、ということがどういうことかを伝えたかったのです。</p>

<h3 id="まとめ">まとめ</h3>

<p>この発表では「よいソフトウェアを開発する方法」を説明しました。より「よい」とは「Ruby らしい」、言い換えると「他と似ている」ということです。これを実現するためのキーとなる考えが「想像するよりも思い出す」です。なぜなら、想像することは知らないことを閃かないといけないので難しく、思い出すことは知っていることから選ぶだけなので簡単だからです。ソフトウェア開発に当てはめてみると、思い出すためには Rubyist としての経験が必要です。あとはその経験を思い出せばよいのです。</p>

<p>しかし、「思い出す」という経験がないので、はじめは「思い出す」ことが難しいことでしょう。「思い出す」経験をするためにはライブラリー開発者になることをオススメします。ライブラリーを開発すると何度も何度も「思い出す」必要があり、とてもよい練習になります。</p>

<p>ライブラリー開発者となり、「思い出す」ことを練習してください。そうすれば、より簡単に、よりうまく「似ていることを思い出してそれと同じようにやる」ことができるようになるはずです。みなさんがよいソフトウェアを開発できるようになる参考になったらうれしいです。</p>

<h2 id="著者紹介">著者紹介</h2>

<p>須藤功平。フリーソフトウェアプログラマーで<a href="http://www.clear-code.com/">株式会社クリアコード</a>代表取締役 (2 代目)。社名の命名者でもある。社名の由来は「クリアなコード」。その名の通りクリアなコードを書く会社であろうという意図を込めている。最近、「よいコードを書くことが当たり前なチーム」になることを支援するサービス「<a href="http://www.clear-code.com/services/commit-comment.html">コミットへのコメントサービス</a>」を始めた。サービスを受けたい開発チーム、クリアコードでこのサービスを担当したい開発者、どちらも募集中。</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>実は、この例の場合は ‘‘save’’ したときと ‘‘restore’’ 直前で描画情報が変わっていないので、’‘save’’ と ‘‘restore’’ は必要ありません。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>http://doc.ruby-lang.org/ja/2.0.0/method/String/i/end_with=3f.html <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>文字列の末尾にマッチする、正規表現のアンカー。 http://doc.ruby-lang.org/ja/2.0.0/doc/spec=2fregexp.html <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>発表後に咳さんにこのことについてコメントをもらいました。 <a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>参考: <a href="https://developer.gnome.org/gobject/stable/gobject-GParamSpec.html#g-param-spec-internal">g_param_spec_internal() のドキュメント</a> <a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>もう少し厳密に言うと、GTK+ が使っているオブジェクトシステムである GObject の内部 <a href="#fnref:6" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:7">
      <p>ここでは Ruby のメソッド名に使えない文字を含むプロパティー名を考えているので、シンボルでプロパティー名を指定するようにはしません。’‘window[:”default-height”]’’ という多くの場合は使わない記法を使わなければいけなくなり、Ruby らしさから外れてしまうからです。 <a href="#fnref:7" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:8">
      <p>ここは難しいと思って欲しいところです。 <a href="#fnref:8" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:9">
      <p>'’Struct’’ は ‘’[]’’ でメンバーにアクセスできるので、ものすごく Ruby らしくないというほどではありません。 <a href="#fnref:9" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:10">
      <p>インストール方法のドキュメントのところにリンクを張るのが親切です。 <a href="#fnref:10" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:11">
      <p>発表時に田中さんからこれに関する質問がありました。発表後に長永さんともこれに関する話をしました。 <a href="#fnref:11" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:12">
      <p><a href="http://snoozer05.rubykaigi.me/">しまだ Ruby 会議</a>に参加したとき、しまださんは「今いる場所」と「ゴール」がわかっている状態で間をどう埋めればよいかを見つけられる人なんだと感じました。しまださんに聞くとなにかよいやり方を教えてもらえるかもしれません。 <a href="#fnref:12" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
  </body>
</html>
