<!DOCTYPE html>
<html>
  



  <head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-41117431-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-41117431-1');
  </script>
  <script src="../../js/gtag.js"></script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>改めて学ぶ RSpec</title>
  <meta name="description" content="">

  <script src="../../js/jquery.min.js"></script>
  <script src="../../js/bootstrap.min.js"></script>
  <link href="../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../../css/theme.css" rel="stylesheet" type="text/css">
  <link href="../../css/syntax.css" rel="stylesheet" type="text/css">
  <link href="../../css/sharebutton.css" rel="stylesheet" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="https://magazine.rubyist.net/articles/0035/0035-RSpecInPractice.html">
  <link rel="alternate" type="application/rss+xml" title="Rubyist Magazine" href="https://magazine.rubyist.net/feed.xml">
  <link rel="shortcut icon" href="../../images/favicon.ico">
</head>

  <body>
    <div class="container-fluid">
        <div class="row full">
            <div class="col-md-2 hidden-xs sidebar">
                <h4>

</h4>

<h4>バックナンバー</h4>
<ul>
    <li><a href="../../articles/backnumber/backnumber.html">記事単位</a></li>
    <hr>
    
        <li><a href="../../articles/kaigi_on_rails/index.html">Kaigi on Rails 特集号</a></li>
    
        <li><a href="../../articles/prerubykaigi2020/preRubyKaigi2020-index.html">RubyKaigi Takeout 2020 特集号</a></li>
    
        <li><a href="../../articles/0061/0061-index.html">0061号(2020-02)</a></li>
    
        <li><a href="../../articles/0060/0060-index.html">0060号(2019-08)</a></li>
    
        <li><a href="../../articles/prerubykaigi2019/preRubyKaigi2019-index.html">RubyKaigi 2019 直前特集号</a></li>
    
        <li><a href="../../articles/0059/0059-index.html">0059号(2019-01)</a></li>
    
        <li><a href="../../articles/0058/0058-index.html">0058号(2018-08)</a></li>
    
        <li><a href="../../articles/prerubykaigi2018/preRubyKaigi2018-index.html">RubyKaigi 2018 直前特集号</a></li>
    
        <li><a href="../../articles/0057/0057-index.html">0057号(2018-02)</a></li>
    
        <li><a href="../../articles/prerubykaigi2017/preRubyKaigi2017-index.html">RubyKaigi 2017 直前特集号</a></li>
    
        <li><a href="../../articles/0056/0056-index.html">0056号(2017-08)</a></li>
    
        <li><a href="../../articles/0055/0055-index.html">0055号(2017-03)</a></li>
    
        <li><a href="../../articles/0054/0054-index.html">0054号(2016-08)</a></li>
    
        <li><a href="../../articles/pretokyorubykaigi11/preTokyoRubyKaigi11-index.html">東京 Ruby 会議 11 直前特集号</a></li>
    
        <li><a href="../../articles/0053/0053-index.html">0053号(2016-04)</a></li>
    
        <li><a href="../../articles/0052/0052-index.html">0052号(2015-12)</a></li>
    
        <li><a href="../../articles/0051/0051-index.html">0051号(2015-09)</a></li>
    
        <li><a href="../../articles/0050/0050-index.html">0050号(2015-05)</a></li>
    
        <li><a href="../../articles/0049/0049-index.html">0049号(2014-12)</a></li>
    
        <li><a href="../../articles/0048/0048-index.html">0048号(2014-09)</a></li>
    
        <li><a href="../../articles/0047/0047-index.html">0047号(2014-06)</a></li>
    
        <li><a href="../../articles/0046/0046-index.html">0046号(2014-04)</a></li>
    
        <li><a href="../../articles/0045/0045-index.html">0045号(2013-12)</a></li>
    
        <li><a href="../../articles/0044/0044-index.html">0044号(2013-09)</a></li>
    
        <li><a href="../../articles/0043/0043-index.html">0043号(2013-07)</a></li>
    
        <li><a href="../../articles/0042/0042-index.html">0042号(2013-05)</a></li>
    
        <li><a href="../../articles/ruby200specialen/Ruby200SpecialEn-index.html">2.0.0 Special (EN)</a></li>
    
        <li><a href="../../articles/0041/0041-index.html">0041号(2013-02)</a></li>
    
        <li><a href="../../articles/0040/0040-index.html">0040号(2012-11)</a></li>
    
        <li><a href="../../articles/0039/0039-index.html">0039号(2012-09)</a></li>
    
        <li><a href="../../articles/rubykaja/kaja.html">RubyKaja のご紹介</a></li>
    
        <li><a href="../../articles/0038/0038-index.html">0038号(2012-05)</a></li>
    
        <li><a href="../../articles/0037/0037-index.html">0037号(2012-02)</a></li>
    
        <li><a href="../../articles/0036/0036-index.html">0036号(2011-11)</a></li>
    
        <li><a href="../../articles/0035/0035-index.html">0035号(2011-09)</a></li>
    
        <li><a href="../../articles/prerubykaigi2011/preRubyKaigi2011-index.html">RubyKaigi2011直前特集号</a></li>
    
        <li><a href="../../articles/0034/0034-index.html">0034号(2011-06)</a></li>
    
        <li><a href="../../articles/0033/0033-index.html">0033号(2011-04)</a></li>
    
        <li><a href="../../articles/0032/0032-index.html">0032号(2011-01)</a></li>
    
        <li><a href="../../articles/0031/0031-index.html">0031号(2010-10)</a></li>
    
        <li><a href="../../articles/prerubykaigi2010/preRubyKaigi2010-index.html">RubyKaigi2010直前特集号</a></li>
    
        <li><a href="../../articles/0030/0030-index.html">0030号(2010-06)</a></li>
    
        <li><a href="../../articles/0029/0029-index.html">0029号(2010-03)</a></li>
    
        <li><a href="../../articles/0028/0028-index.html">0028号(2009-12)</a></li>
    
        <li><a href="../../articles/0027/0027-index.html">0027号(2009-09)</a></li>
    
        <li><a href="../../articles/0026/0026-index.html">0026号(2009-06)</a></li>
    
        <li><a href="../../articles/0025/0025-index.html">0025号(2009-02)</a></li>
    
        <li><a href="../../articles/0024/0024-index.html">0024号(2008-10)</a></li>
    
        <li><a href="../../articles/0023/0023-index.html">0023号(2008-03)</a></li>
    
        <li><a href="../../articles/0022/0022-index.html">0022号(2007-12)</a></li>
    
        <li><a href="../../articles/0021/0021-index.html">0021号(2007-09)</a></li>
    
        <li><a href="../../articles/0020/0020-index.html">0020号(2007-08)</a></li>
    
        <li><a href="../../articles/0019/0019-index.html">0019号(2007-05)</a></li>
    
        <li><a href="../../articles/0018/0018-index.html">0018号(2007-02)</a></li>
    
        <li><a href="../../articles/0017/0017-index.html">0017号(2006-11)</a></li>
    
        <li><a href="../../articles/0016/0016-index.html">0016号(2006-09)</a></li>
    
        <li><a href="../../articles/0015/0015-index.html">0015号(2006-07)</a></li>
    
        <li><a href="../../articles/rubykaigi2006/RubyKaigi2006-index.html">日本 Ruby カンファレンス 2006 特別号</a></li>
    
        <li><a href="../../articles/0014/0014-index.html">0014号(2006-05)</a></li>
    
        <li><a href="../../articles/0013/0013-index.html">0013号(2006-02)</a></li>
    
        <li><a href="../../articles/0012/0012-index.html">0012号(2005-12)</a></li>
    
        <li><a href="../../articles/0011/0011-index.html">0011号(2005-11)</a></li>
    
        <li><a href="../../articles/0010/0010-index.html">0010号(2005-10)</a></li>
    
        <li><a href="../../articles/0009/0009-index.html">0009号(2005-09)</a></li>
    
        <li><a href="../../articles/0008/0008-index.html">0008号(2005-07)</a></li>
    
        <li><a href="../../articles/0007/0007-index.html">0007号(2005-06)</a></li>
    
        <li><a href="../../articles/0006/0006-index.html">0006号(2005-05)</a></li>
    
        <li><a href="../../articles/0005/0005-index.html">0005号(2005-02)</a></li>
    
        <li><a href="../../articles/0004/0004-index.html">0004号(2004-12)</a></li>
    
        <li><a href="../../articles/0003/0003-index.html">0003号(2004-11)</a></li>
    
        <li><a href="../../articles/0002/0002-index.html">0002号(2004-10)</a></li>
    
        <li><a href="../../articles/0001/0001-index.html">0001号(2004-09)</a></li>
    
</ul>
<p class="rss-subscribe"><a href="/feed.xml">RSS</a></p>

            </div>
            <div class="col-md-10 main">
                <div class="row">
                    <div class="col-md-12">
                        <img src="../../images/rubima_logo_l.png">
                        <h1>改めて学ぶ RSpec</h1>
                        <div class="social-buttons">
                            <div class='sns'>            
    <ul class="clearfix">
       <li class="twitter"><a href="https://twitter.com/share?text=改めて学ぶ RSpec&amp;url=https://magazine.rubyist.net/articles/0035/0035-RSpecInPractice.html" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa fa-twitter"></i></a></li>
       <li class="facebook"><a href="https://www.facebook.com/sharer.php?u=https://magazine.rubyist.net/articles/0035/0035-RSpecInPractice.html&amp;t=改めて学ぶ RSpec" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa fa-facebook"></i></a></li>
       <li class="hatebu"><a href="http://b.hatena.ne.jp/add?mode=confirm&amp;url=https://magazine.rubyist.net/articles/0035/0035-RSpecInPractice.html&amp;改めて学ぶ RSpec" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa">B!</i></a></li>
    </ul>
</div>
                        </div>
                        <div class="post_info">
                            

  <span class="created_on">初稿：2011-09-26</span>



                        </div>
                        
<ul id="markdown-toc">
  <li><a href="#はじめに" id="markdown-toc-はじめに">はじめに</a></li>
  <li><a href="#xunit-っぽいコードから-rspec-らしいコードへ" id="markdown-toc-xunit-っぽいコードから-rspec-らしいコードへ">xUnit っぽいコードから RSpec らしいコードへ</a>    <ul>
      <li><a href="#xunit-っぽい-rspec-のコード" id="markdown-toc-xunit-っぽい-rspec-のコード">xUnit っぽい RSpec のコード</a></li>
      <li><a href="#describe-と-context" id="markdown-toc-describe-と-context">describe と context</a>        <ul>
          <li><a href="#段階的に仕様をテストコードに落とし込む" id="markdown-toc-段階的に仕様をテストコードに落とし込む">段階的に仕様をテストコードに落とし込む</a></li>
        </ul>
      </li>
      <li><a href="#subject" id="markdown-toc-subject">subject</a></li>
      <li><a href="#describe-のネスト-と-subject" id="markdown-toc-describe-のネスト-と-subject">describe のネスト と subject</a></li>
      <li><a href="#it-に文字列を渡すのか渡さないのか" id="markdown-toc-it-に文字列を渡すのか渡さないのか">it に文字列を渡すのか、渡さないのか</a></li>
      <li><a href="#let-でデータ以外の部分だけを共通化する" id="markdown-toc-let-でデータ以外の部分だけを共通化する">let でデータ以外の部分だけを共通化する</a></li>
      <li><a href="#shared_context" id="markdown-toc-shared_context">shared_context</a></li>
    </ul>
  </li>
  <li><a href="#情報源" id="markdown-toc-情報源">情報源</a></li>
  <li><a href="#終わりに" id="markdown-toc-終わりに">終わりに</a></li>
  <li><a href="#著者について" id="markdown-toc-著者について">著者について</a></li>
</ul>

<p>書いた人 : 赤松 祐希 (<a href="http://twitter.com/ukstudio">@ukstudio</a>)</p>

<h2 id="はじめに">はじめに</h2>

<p>当記事は Ruby のテスティングフレームワーク、RSpec の解説記事です。 入門記事ではなく、比較的実践的な内容を目指しているので it や describe やテストの実行の仕方など最低限の RSpec の知識ある人を対象としています。</p>

<p>RSpec は今やメジャーなテスティングフレームワークとなりましたが、実は日本語での情報はあまりありません。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>
そういった背景から大多数の人が RSpec をうまく使いこなせているとは言えず、RSpec らしくないテストコードを見かけることが多々あります。</p>

<p>この記事の目的はそういった状況を少しでも改善するために、RSpec に興味がある、もしくは使っているが今一使いこなせてるように感じない人に向け RSpec の使い方を指南することです。</p>

<h2 id="xunit-っぽいコードから-rspec-らしいコードへ">xUnit っぽいコードから RSpec らしいコードへ</h2>

<h3 id="xunit-っぽい-rspec-のコード">xUnit っぽい RSpec のコード</h3>

<p>ここでいう「xUnit っぽい」というのは、簡単に言えば RSpec の機能を使いこなすことなく、it を xUnit のテストメソッドと同じように扱ってしまっているものをさします。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="no">Stack</span> <span class="k">do</span>
    <span class="n">before</span> <span class="k">do</span>
      <span class="vi">@stack</span> <span class="o">=</span> <span class="no">Stack</span><span class="p">.</span><span class="nf">new</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s1">'#pushの返り値はpushした値であること'</span> <span class="k">do</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="s1">'value'</span><span class="p">).</span><span class="nf">should</span> <span class="n">eq</span> <span class="s1">'value'</span>
    <span class="k">end</span>
    <span class="n">it</span> <span class="s1">'スタックが空の場合、#popの返り値はnilであること'</span> <span class="k">do</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">.</span><span class="nf">should</span> <span class="n">be_nil</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s1">'スタックに値がある場合、#popで最後の値を取得すること'</span> <span class="k">do</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value1'</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value2'</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">.</span><span class="nf">should</span> <span class="n">eq</span> <span class="s1">'value2'</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">.</span><span class="nf">should</span> <span class="n">eq</span> <span class="s1">'value1'</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s1">'#sizeはスタックのサイズを返すこと'</span> <span class="k">do</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">size</span><span class="p">.</span><span class="nf">should</span> <span class="n">eq</span> <span class="mi">0</span>

      <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value'</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">size</span><span class="p">.</span><span class="nf">should</span> <span class="n">eq</span> <span class="mi">1</span>
    <span class="k">end</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>上記のテストコードは RSpec でスタック構造をあらわす Stack クラスに対して書かれたものです。Stack クラスは push、pop、size の 3 つのメソッドを持ちます。</p>

<p>xUnit では基本的にテストメソッドは全てフラットに定義されます (最近ではそうじゃないものも増えてきましたが) ので、このテストコードは xUnit ぽいテストコードと言っていいでしょう。テストメソッドがそのまま it に置き換わっただけですし、before ブロックも setup メソッドのようにしか使っていません。</p>

<h3 id="describe-と-context">describe と context</h3>

<p>さきほどのテストコードをいくつかの手順を踏んで修正してみましょう。まずは describe です。describe は RSpec でテストコードを書くときは必ず一つは登場するものですが、同じレベルで並べたりネストさせたりすることができます。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="no">Stack</span> <span class="k">do</span>
    <span class="n">before</span> <span class="k">do</span>
      <span class="vi">@stack</span> <span class="o">=</span> <span class="no">Stack</span><span class="p">.</span><span class="nf">new</span>
    <span class="k">end</span>

    <span class="n">describe</span> <span class="s1">'#push'</span> <span class="k">do</span>
      <span class="n">it</span> <span class="s1">'返り値はpushした値であること'</span> <span class="k">do</span>
        <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="s1">'value'</span><span class="p">).</span><span class="nf">should</span> <span class="n">eq</span> <span class="s1">'value'</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="s1">'nilをpushした場合は例外であること'</span> <span class="k">do</span>
        <span class="nb">lambda</span> <span class="p">{</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="kp">nil</span><span class="p">)</span> <span class="p">}.</span><span class="nf">should</span> <span class="n">raise_error</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">describe</span> <span class="s1">'#pop'</span> <span class="k">do</span>
      <span class="n">it</span> <span class="s1">'スタックが空の場合、#popの返り値はnilであること'</span> <span class="k">do</span>
        <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">.</span><span class="nf">should</span> <span class="n">be_nil</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="s1">'スタックに値がある場合、#popで最後の値を取得すること'</span> <span class="k">do</span>
        <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value1'</span>
        <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value2'</span>
        <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">.</span><span class="nf">should</span> <span class="n">eq</span> <span class="s1">'value2'</span>
        <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">.</span><span class="nf">should</span> <span class="n">eq</span> <span class="s1">'value1'</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">describe</span> <span class="s1">'#size'</span> <span class="k">do</span>
      <span class="n">it</span> <span class="s1">'#sizeはスタックのサイズを返すこと'</span> <span class="k">do</span>
        <span class="vi">@stack</span><span class="p">.</span><span class="nf">size</span><span class="p">.</span><span class="nf">should</span> <span class="n">eq</span> <span class="mi">0</span>

        <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value'</span>
        <span class="vi">@stack</span><span class="p">.</span><span class="nf">size</span><span class="p">.</span><span class="nf">should</span> <span class="n">eq</span> <span class="mi">1</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>describe を使うことでテストコードに構造がうまれました。各テストケースがグルーピングされることによって、テストケースが何についてテストを行なっているのかわかりやすくなります。</p>

<p>次に context です。context は describe のエイリアスでしかありませんが使う目的が違います。ひとことで言うなら、 describe はテストする対象をあらわし、 context はテストする時の状況をあらわします。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="no">Stack</span> <span class="k">do</span>
    <span class="n">before</span> <span class="k">do</span>
      <span class="vi">@stack</span> <span class="o">=</span> <span class="no">Stack</span><span class="p">.</span><span class="nf">new</span>
    <span class="k">end</span>

    <span class="n">describe</span> <span class="s1">'#push'</span> <span class="k">do</span>
      <span class="n">context</span> <span class="s1">'正常値'</span> <span class="k">do</span>
        <span class="n">it</span> <span class="s1">'返り値はpushした値であること'</span> <span class="k">do</span>
          <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="s1">'value'</span><span class="p">).</span><span class="nf">should</span> <span class="n">eq</span> <span class="s1">'value'</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">context</span> <span class="s1">'nilをpushした場合'</span> <span class="k">do</span>
        <span class="n">it</span> <span class="s1">'例外であること'</span> <span class="k">do</span>
          <span class="nb">lambda</span> <span class="p">{</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="kp">nil</span><span class="p">)</span> <span class="p">}.</span><span class="nf">should</span> <span class="n">raise_error</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">describe</span> <span class="s1">'#pop'</span> <span class="k">do</span>
      <span class="n">context</span> <span class="s1">'スタックが空の場合'</span> <span class="k">do</span>
        <span class="n">it</span> <span class="s1">'返り値はnilであること'</span> <span class="k">do</span>
          <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">.</span><span class="nf">should</span> <span class="n">be_nil</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">context</span> <span class="s1">'スタックに値がある場合'</span> <span class="k">do</span>
        <span class="n">it</span> <span class="s1">'最後の値を取得すること'</span> <span class="k">do</span>
          <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value1'</span>
          <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value2'</span>
          <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">.</span><span class="nf">should</span> <span class="n">eq</span> <span class="s1">'value2'</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">describe</span> <span class="s1">'#size'</span> <span class="k">do</span>
      <span class="n">it</span> <span class="s1">'スタックのサイズを返すこと'</span> <span class="k">do</span>
        <span class="vi">@stack</span><span class="p">.</span><span class="nf">size</span><span class="p">.</span><span class="nf">should</span> <span class="n">eq</span> <span class="mi">0</span>

        <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value'</span>
        <span class="vi">@stack</span><span class="p">.</span><span class="nf">size</span><span class="p">.</span><span class="nf">should</span> <span class="n">eq</span> <span class="mi">1</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>今回、describe はメソッド単位でわけました。理由としてはテストケースを書くときは何らかのメソッドを対象としていることがほとんどのため、このようにわけた方がテストが書き易いことが多いためです。またメソッド単位でわけることでドキュメントとしても読み易くなります。</p>

<p>ですが、テストの対象となるものはメソッドだけとは限りませんし、複数のオブジェクトのコラボレーションをテストしたいこともあるでしょう。そのときは素直に自分がわかりやすいと思うように describe をわければいいでしょう。メソッド単位にこだわる必要はあまりありません。</p>

<h4 id="段階的に仕様をテストコードに落とし込む">段階的に仕様をテストコードに落とし込む</h4>

<p>describe と context の概念は個人的には非常に重要な概念だと思っています。というのもアプリケーションの仕様をテストコードに落とし込むにあたって、思考ツールとして機能するためです。</p>

<p>例えば、先程の Stack クラスについてテストコードを書くときに、大抵まずはどのメソッドから実装しようかを考えると思います。その時に push メソッドから実装しようとしたと考えたとしましょう。</p>

<p>まずは push メソッドをテスト対象とする describe を用意します。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="no">Stack</span> <span class="k">do</span>
    <span class="n">describe</span> <span class="s1">'#push'</span> <span class="k">do</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>対象が決まったら、次はそのメソッドを呼び出す状況を考えます。push メソッドの場合、最初に思いつくのは、そのまま値を保存する状況でしょう。この時は、まだ他に context がないのでそのまま it にしてしまうことができます。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="no">Stack</span> <span class="k">do</span>
    <span class="n">describe</span> <span class="s1">'#push'</span> <span class="k">do</span>
      <span class="n">it</span> <span class="s1">'値が保存されること'</span>
    <span class="k">end</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>正常値について考えたら、異常値についても考えるので、nil を保存しようとした時に例外が発生する状況について考えます。先程の正常値とは状況が違うので、今度は context をわける必要があります。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="no">Stack</span> <span class="k">do</span>
    <span class="n">describe</span> <span class="s1">'#push'</span> <span class="k">do</span>
      <span class="n">context</span> <span class="s1">'正常値'</span> <span class="k">do</span>
        <span class="n">it</span> <span class="s1">'値が保存されること'</span>
      <span class="k">end</span>

      <span class="n">context</span> <span class="s1">'nilの場合'</span> <span class="k">do</span>
        <span class="n">it</span> <span class="s1">'例外になること'</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>このように describe、context、it と順番を踏むことで仕様を段階的にテストコードに落とし込んでいきやすくなります。describe と context を使うことでアプリケーションの仕様を整理し、設計を行ないやすくなります。</p>

<h3 id="subject">subject</h3>

<p>RSpec では subject を使うことで should のレシーバを省略することができます。先程のテストコードの一部を subject を使って書き直してみます。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="s1">'#pop'</span> <span class="k">do</span>
    <span class="n">subject</span> <span class="p">{</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span> <span class="p">}</span>

    <span class="n">context</span> <span class="s1">'スタックが空の場合'</span> <span class="k">do</span>
      <span class="n">it</span> <span class="s1">'返り値はnilであること'</span> <span class="k">do</span>
        <span class="n">should</span> <span class="n">be_nil</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">context</span> <span class="s1">'スタックに値がある場合'</span> <span class="k">do</span>
      <span class="n">before</span> <span class="k">do</span>
        <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value1'</span>
        <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value2'</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="s1">'最後の値を取得すること'</span> <span class="k">do</span>
        <span class="n">should</span> <span class="n">eq</span> <span class="s1">'value2'</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>subject のメリットはテスト対象が明確になること、そしてほぼ強制的にひとつのテストケースにひとつのアサーションしか書けなくなることです。テストを書くときに「今何をテストしているのか」ということを意識するのは重要です。describe を切った時点である程度明確になっていますが、subject に比べると若干弱いのは否めません。subject を使うと例えばメソッドを実行した後のオブジェクトの状態をテストしているのか、もしくはメソッドの返り値をテストしているのかという普段つい曖昧にしがちな部分もはっきりと分けることができます。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="no">Array</span><span class="p">,</span> <span class="s1">'#delete'</span> <span class="k">do</span>
    <span class="n">subject</span> <span class="p">{</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nf">delete</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">eq</span> <span class="mi">3</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="no">Array</span><span class="p">,</span> <span class="s1">'#delete'</span> <span class="k">do</span>
    <span class="n">before</span> <span class="k">do</span>
      <span class="vi">@array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
      <span class="vi">@array</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">subject</span> <span class="p">{</span> <span class="vi">@array</span> <span class="p">}</span>
    <span class="n">its</span><span class="p">(</span><span class="ss">:size</span><span class="p">)</span> <span class="p">{</span> <span class="n">should</span> <span class="n">eq</span> <span class="mi">2</span> <span class="p">}</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>そして、should のレシーバを省略することでひとつのテストケースにひとつのアサーションしか書けなくなります。一般的にテストケースにはひとつのアサーションを書くのがよいとされており、subject をうまく使うことで自然とそのようなテストを書くようになります。</p>

<h3 id="describe-のネスト-と-subject">describe のネスト と subject</h3>

<p>場合によっては、関連先のオブジェクトについてもテストしたい場合があります。例えば User クラスと それに関連する Profile クラスなどが考えられます。この場合、subject を使って should のレシーバを省略すると関連先のオブジェクトにアクセスできないのでテストすることができません。解決するには 新たに describe をネストさせてもう一度 subject を定義しましょう。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="no">User</span><span class="p">,</span> <span class="s1">'#create!'</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@user</span><span class="o">=</span><span class="no">User</span><span class="p">.</span><span class="nf">create!</span> <span class="p">}</span>
    <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_new_record</span> <span class="p">}</span>

    <span class="n">descirbe</span> <span class="no">Profile</span> <span class="k">do</span>
      <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span><span class="p">.</span><span class="nf">profile</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_new_record</span> <span class="p">}</span>
      <span class="n">its</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">{</span> <span class="n">should</span> <span class="n">eq</span> <span class="s1">'AKAMATSU Yuki'</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>このようにして関連先のオブジェクトもテストすることができます。Rails のアプリケーションを開発している場合、こういうケースは結構あるのではないかと思います。</p>

<p>もうひとつ、 its を使う方法もあります。テストする箇所が少ない場合はこちらでもいいでしょう。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="no">User</span><span class="p">,</span> <span class="s1">'#create!'</span> <span class="k">do</span>
    <span class="n">subject</span> <span class="p">{</span> <span class="no">User</span><span class="p">.</span><span class="nf">creat!</span> <span class="p">}</span>
    <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_new_record</span> <span class="p">}</span>
    <span class="n">its</span><span class="p">(</span><span class="ss">:profile</span><span class="p">)</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_new_record</span> <span class="p">}</span>
    <span class="n">its</span><span class="p">(</span><span class="s1">'profile.name'</span><span class="p">)</span> <span class="p">{</span> <span class="n">should</span> <span class="n">eq</span> <span class="s1">'AKAMATSU Yuki'</span> <span class="p">}</span>
  <span class="k">end</span>

</code></pre></div></div>

<h3 id="it-に文字列を渡すのか渡さないのか">it に文字列を渡すのか、渡さないのか</h3>

<p>さて、途中から書き方を変えていたので気づいた方もいるかもしれませんが、it に与える文字列は省略することができます。このように書くと、「it should be nil」といった風に RSpec のコードをそのまま英文のように読めるため文字列を渡さずともそれなりにテストの内容をそのまま読めるようになります。</p>

<p>RSpec のよくある議論のひとつに、it に文字列を渡すのかどうかというものがあります。筆者の感覚ですと RSpec の最新版を絶えず追っているような人は文字列を省く傾向があるように思えます。筆者も基本的には省いて RSpec のコードのみでテストを表現するようにしています。</p>

<p>理由としては、it に文字列を渡す書き方だとコメントとコードの乖離と同じような問題があるためです。最近のよいコードの書き方の指針のひとつに「コメントを書かなくても内容がわかるコードを書く」というものがあります。理由としてはコメントとコードの両方があるのは DRY (Don’t Repeat Yourself) ではなく、コメントもしくはコードのどちらかだけが修正され内容が一致しなくなるといった問題が起きるためです。</p>

<p>RSpec の it と文字列にも同じことが言えます。中のテストケースが修正されているにもかかわらず、it の引数の文字列が修正されず内容が一致しなくなることは十分にありえます。また、文字列を毎回渡しているとどうしてもテストコードの行数が長くなってしまい見通しがわるくなってしまいます。</p>

<p>とは言え、省略した場合に何も問題がないわけでもありません。私は日本人ですし、多分この記事を読まれている方のほとんども日本人でしょう。日本人ならやはり日本語で書かれている方がわかりやすいはずです。また、RSpec の実行オプションに「–format documentation」を指定した時のドキュメントもわかりづらくなってしまいます。例えば先程の Stack クラスの 「最後の値を取得すること」というテスト内容が「should eq ‘value2’」となってしまい仕様が読み取れません。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> Stack
   #pop
     スタックが空の場合
       返り値はnilであること
     スタックに値がある場合
       最後の値を取得すること</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> Stack
   #pop
     スタックが空の場合
       should be nil
     スタックに値がある場合
       should == value2</code></pre></figure>

<p>こちらはいくつか解決する方法があります。1つは context に具体的な値を入れてしまう方法、もうひとつは カスタムマッチャを定義してしまうことです。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="no">RSpec</span><span class="o">::</span><span class="no">Matchers</span><span class="p">.</span><span class="nf">define</span> <span class="ss">:be_latest_value</span> <span class="k">do</span> <span class="o">|</span><span class="n">expected</span><span class="o">|</span>
    <span class="n">match</span> <span class="k">do</span> <span class="o">|</span><span class="n">actual</span><span class="o">|</span>
      <span class="n">actual</span> <span class="o">==</span> <span class="n">latest_value</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="no">Stack</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{</span> <span class="vi">@stack</span> <span class="o">=</span> <span class="no">Stack</span><span class="p">.</span><span class="nf">new</span> <span class="p">}</span>
    <span class="n">describe</span> <span class="s1">'#pop'</span> <span class="k">do</span>
      <span class="n">subject</span> <span class="p">{</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span> <span class="p">}</span>

      <span class="n">context</span> <span class="s1">'スタックが空の場合'</span> <span class="k">do</span>
        <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_nil</span> <span class="p">}</span>
      <span class="k">end</span>

      <span class="c1"># 具体的な値をcontextに書く</span>
      <span class="n">context</span> <span class="s1">'スタックの最後の値が"value2"の場合'</span> <span class="k">do</span>
        <span class="n">before</span> <span class="k">do</span>
          <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value1'</span>
          <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value2'</span>
        <span class="k">end</span>

        <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">eq</span> <span class="s1">'value2'</span> <span class="p">}</span>
      <span class="k">end</span>

      <span class="c1"># カスタムマッチャでメッセージを調整する</span>
      <span class="n">context</span> <span class="s1">'スタックに値がある場合'</span> <span class="k">do</span>
        <span class="n">let</span><span class="p">(</span><span class="ss">:latest_value</span><span class="p">)</span> <span class="p">{</span> <span class="s1">'value2'</span> <span class="p">}</span>
        <span class="n">before</span> <span class="k">do</span>
          <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value1'</span>
          <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="n">latest_value</span>
        <span class="k">end</span>

        <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_latest_value</span> <span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

</code></pre></div></div>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> Stack
   #pop
     スタックが空の場合
       should be nil
     スタックの最後の値が"value2"の場合
       should == value2
     スタックに値がある場合
       should be latest value</code></pre></figure>

<p>context で具体的な値を明示することで RSpec の出力から最後の値を取得する仕様だというのが推測できます。カスタムマッチャは定義したものがそのまま出力されるので、こちらの方がより仕様としてわかりやすいでしょう。</p>

<p>ですが、実際筆者がここまでやるかというとあまりやりません。せいぜい、context の文言を気にする程度でしょうか<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>。なぜならプログラマとしては RSpec が出力するドキュメントよりテストコードの方が重要なため、RSpec の出力結果だけを見るということはあまりないためです。なので、テストコードが読みやすく書かれているのであれば、ドキュメントとして意味がわかりにくい文章が出力されていてもあまり気にならないでしょう。</p>

<p>結論としては、筆者としては it には文字列を使わない書き方をおすすめします。やはり文字列とテスト内容が DRY ではないというのが理由としては大きいです。また、今回はサンプルが小さいのであまり気にならないと思いますが、実際はもっとたくさんのテストケースがあるのが普通です。そうなると文字列を省いた方がテストコード全体がコンパクトになります。</p>

<p>以上の理由から個人的には文字列を使わない書き方をおすすめしますが、当然文字列をちゃんと書くという人もいます。<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>なので、自分なりにでいいので、どちらがいいのか考えてみてください。どちらにもいい点悪い点はあるので絶対的にどちらが正しいというのはありません。</p>

<h3 id="let-でデータ以外の部分だけを共通化する">let でデータ以外の部分だけを共通化する</h3>

<p>RSpec には let という機能があります。subject などに比べるとあまり知られておらず、知っていても使い方がよくわからないという方も多いようなので解説したいと思います。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">descirbe</span> <span class="s1">'let'</span> <span class="k">do</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span> <span class="p">{</span> <span class="s1">'foo'</span> <span class="p">}</span>
    <span class="n">specify</span> <span class="p">{</span> <span class="n">foo</span><span class="p">.</span><span class="nf">should</span> <span class="n">eq</span> <span class="s1">'foo'</span> <span class="p">}</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>let はブロックの評価値が、引数として渡されたシンボルと同名の変数に格納されます。上記の例ではブロックの評価値が文字列 ‘foo’ でシンボルが :foo なので foo という変数名に文字列 ‘foo’ が格納されています。動作としては遅延評価される仕組みになっており<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>、実際に呼び出しされるまでは実行されません。また、同じテストケース内ではブロックの評価値はキャッシュされており、複数回呼び出したときに毎回処理を行なうということはおきません。</p>

<p>テストを書くとき、事前処理や呼び出すメソッドは同じでも使うデータだけが違うという場合があります。その時はそれぞれの describe や context の before の中で同じ処理を毎回書くか、テスト用のヘルパーメソッドを書くなどするしかありませんでしたが、let を使うともう少しスマートに書くことができます。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="no">User</span><span class="p">,</span> <span class="s1">'#admin?'</span> <span class="k">do</span>
    <span class="n">before</span> <span class="k">do</span>
      <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s1">'jack'</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>

    <span class="n">context</span> <span class="s1">'admin'</span> <span class="k">do</span>
      <span class="n">before</span> <span class="k">do</span>
        <span class="vi">@user</span><span class="p">.</span><span class="nf">role</span> <span class="o">=</span> <span class="no">Role</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:role</span> <span class="o">=&gt;</span> <span class="ss">:admin</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_admin</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="n">context</span> <span class="s1">'not admin'</span> <span class="k">do</span>
      <span class="n">before</span> <span class="k">do</span>
        <span class="vi">@user</span><span class="p">.</span><span class="nf">role</span> <span class="o">=</span> <span class="no">Role</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:role</span> <span class="o">=&gt;</span> <span class="ss">:normal</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_admin</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>User クラスは内部に Role クラスを持ち、その Role の状態によって admin? メソッドの結果がかわります。このテストコードは let を使わず before と subject だけで書かれています。admin の context と not admin の context の違いは Role クラスに渡す引数だけです。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="no">User</span><span class="p">,</span> <span class="s1">'#admin?'</span> <span class="k">do</span>
    <span class="n">before</span> <span class="k">do</span>
      <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s1">'jack'</span><span class="p">)</span>
      <span class="vi">@user</span><span class="p">.</span><span class="nf">role</span> <span class="o">=</span> <span class="no">Role</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:role</span> <span class="o">=&gt;</span> <span class="n">role</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">subject</span> <span class="p">{</span> <span class="vi">@user</span> <span class="p">}</span>

    <span class="n">context</span> <span class="s1">'admin'</span> <span class="k">do</span>
      <span class="n">let</span><span class="p">(</span><span class="ss">:role</span><span class="p">)</span> <span class="p">{</span> <span class="ss">:admin</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_admin</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="n">context</span> <span class="s1">'not admin'</span> <span class="k">do</span>
      <span class="n">let</span><span class="p">(</span><span class="ss">:role</span><span class="p">)</span> <span class="p">{</span> <span class="ss">:normal</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should_not</span> <span class="n">be_admin</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>let を使うとデータの定義の部分だけを抜き出すことができるので、Role の設定もひとつの before の中ですませることができます。先程のテストコードよりこちらの方が DRY でコードの見通しもよくなっています。これが let の最もオーソドックスな使い方だと思います。</p>

<p>もちろん、単純にインスタンス変数の置き換えとしても使うことができます。このあたりは好みの問題の気も若干しますが、データの定義を宣言的に書くことができるので大体の場合は見やすくなるでしょう。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="no">Stack</span><span class="p">,</span> <span class="s1">'#pop'</span> <span class="k">do</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:stack</span><span class="p">)</span> <span class="p">{</span> <span class="no">Stack</span><span class="p">.</span><span class="nf">new</span> <span class="p">}</span>
    <span class="n">subject</span> <span class="p">{</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span> <span class="p">}</span>

    <span class="n">context</span> <span class="s1">'スタックが空の場合'</span> <span class="k">do</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">be_nil</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="n">context</span> <span class="s1">'スタックに値がある場合'</span> <span class="k">do</span>
      <span class="n">let</span><span class="p">(</span><span class="ss">:oldest_value</span><span class="p">)</span> <span class="p">{</span> <span class="s1">'value1'</span> <span class="p">}</span>
      <span class="n">let</span><span class="p">(</span><span class="ss">:latest_value</span><span class="p">)</span> <span class="p">{</span> <span class="s1">'value2'</span> <span class="p">}</span>

      <span class="n">before</span> <span class="k">do</span>
        <span class="n">stack</span><span class="p">.</span><span class="nf">push</span> <span class="n">oldest_value</span>
        <span class="n">stack</span><span class="p">.</span><span class="nf">push</span> <span class="n">latest_value</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">eq</span> <span class="n">latest_value</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>

</code></pre></div></div>

<h3 id="shared_context">shared_context</h3>

<p>RSpec の context はさきほど説明した通り、テストの状況を分けるために使うものですが context 自体は describe のエイリアスなので特になにかをしてくれるというわけではありません。実際にテストの状況をわけるためには before や subject などを使う必要があります。</p>

<p>実は同じコンテキストでもひとつの context の中にまとめられないことが多々あります。例えば、複数のメソッドのテストで同じコンテキストを使いたい時などがそうです。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="s1">'#method_a'</span> <span class="k">do</span>
    <span class="n">context</span> <span class="s1">'#context_a'</span> <span class="k">do</span>
      <span class="n">before</span> <span class="p">{}</span> <span class="c1"># DRYじゃない</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="s1">'#method_b'</span> <span class="k">do</span>
    <span class="n">context</span> <span class="s1">'#context_a'</span> <span class="k">do</span>
      <span class="n">before</span> <span class="p">{}</span> <span class="c1"># DRYじゃない</span>
    <span class="k">end</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>describe と context のネストを逆にすることで解決できそうな気もしますが、普通あるメソッドに対するテストは複数のコンテキストで行いますから今度は同じメソッドに対するテストがバラバラに記述されてしまいます。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">context</span> <span class="s1">'#context_a'</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{}</span>

    <span class="n">describe</span> <span class="s1">'#method_a'</span> <span class="k">do</span>
    <span class="k">end</span>

    <span class="n">describe</span> <span class="s1">'#method_b'</span> <span class="k">do</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">context</span> <span class="s1">'#context_b'</span> <span class="k">do</span>
    <span class="n">before</span> <span class="p">{}</span>

    <span class="n">describe</span> <span class="s1">'#method_a'</span> <span class="k">do</span>
    <span class="k">end</span>

    <span class="n">describe</span> <span class="s1">'#method_b'</span> <span class="k">do</span>
    <span class="k">end</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>バラバラになるとはいえ、これはこれでうまく構造化できているような気がします。ですが、これにはひとつ大きな問題があります。先程、段階的に仕様をテストコードに落とし込むという話で最初に describe を分けるところからはじめました。それと同じ理由で、これからテストしようと思う describe があってその次にテストする状況としての context があるので context が describe より上に来るのは自然ではありません。なので私はこの書き方はおすすめしません。</p>

<p>これを解決するためには shared_context を使います。shared_context はその名前の通りコンテキスト (テストを行なうときの状況) を共有するための機能です。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">shared_context</span> <span class="s1">'要素がふたつpushされている'</span> <span class="k">do</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:latest_value</span><span class="p">)</span> <span class="p">{</span> <span class="s1">'value2'</span> <span class="p">}</span>
    <span class="n">before</span> <span class="k">do</span>
      <span class="vi">@stack</span> <span class="o">=</span> <span class="no">Stack</span><span class="p">.</span><span class="nf">new</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'value1'</span>
      <span class="vi">@stack</span><span class="p">.</span><span class="nf">push</span> <span class="n">latest_value</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="no">Stack</span> <span class="k">do</span>
    <span class="n">describe</span> <span class="s1">'#size'</span> <span class="k">do</span>
      <span class="n">include_context</span> <span class="s1">'要素がふたつpushされている'</span>
      <span class="n">subject</span> <span class="p">{</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">size</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">eq</span> <span class="mi">2</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="n">describe</span> <span class="s1">'#pop'</span> <span class="k">do</span>
      <span class="n">include_context</span> <span class="s1">'要素がふたつpushされている'</span>
      <span class="n">subject</span> <span class="p">{</span> <span class="vi">@stack</span><span class="p">.</span><span class="nf">pop</span> <span class="p">}</span>
      <span class="n">it</span> <span class="p">{</span> <span class="n">should</span> <span class="n">eq</span> <span class="n">latest_value</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>shared_context を使うことで複数箇所にちらばる同一処理をまとめることができます。shared_context は shared_context が書かれたファイルを require することでも使えるようになるので別のスペックファイルでも使うことができます。</p>

<h2 id="情報源">情報源</h2>

<p>RSpec を使うとなったときに使い方についてどこで知ればいいのかと困る人も多いようです。実際、日本語での情報はあまり多くありません。本記事はそういう状況を少しでも改善できたらと思い書きましたがやはりこれでも十分ではありません。</p>

<p>なので現時点ではやはり大元のドキュメントを参照するのが一番でしょう。<a href="http://rspec.info/">rspec.info</a> は現在ほぼ更新されていないので、Relish の方の <a href="http://www.relishapp.com/rspec">RSpec Documentation</a> を見ることをおすすめします。</p>

<p>Relish は Cucumber のシナリオをドキュメントとして表示してくれるので基本的にはこれが最新のドキュメントと思えばいいでしょう。ただ、Relish のドキュメントは API ドキュメントに近く、使い方はわかってもそれを活用する方法がわからない場合もあります。例えば私は最初 let のメリットがよくわからず、しばらく手元で let を使ったテストコードを何回か書いて理解したりしました。</p>

<p>この辺りの問題はなかなかむずかしく、ググって調べるか人に聞くなどするしかありません。もちろん自分で考えるという方法もあります。人に聞く場合は twitter などで発言すれば誰かが答えてくれるかもしれません。</p>

<p>RSpec に関するコミュニティは私は <a href="https://github.com/testing-rails-rspec-ja/community">Testing w/ Rails using RSpec in Japanese</a> ぐらいしか知りませんが、あまり活発に活動しているわけでもありません。ただ少なくとも私は普段からチェックしていますし、Facebook にグループがあるのでそちらで質問を投げてもらえればわかる範囲でお答えできます。他の人も見てれば答えてくれるでしょう。もちろん、今この記事を見ているあなたも答えてもらって大丈夫です。むしろぜひ答えてください。github に wiki があるのでそちらに自分の知っていることを書くことも歓迎します。</p>

<h2 id="終わりに">終わりに</h2>

<p>RSpec はよく「難しい」とか「構文がわかりづらい」と言われます。Rubyist はものごとをきっと Ruby のコードで考えるのでそのコードと RSpec の DSL にギャップがあるからなのかなと個人的には思っています。正直、この辺は慣れの問題でしょう。もちろん、どうしても受け付けないという人はいると思います。</p>

<p>そういう人はまず describe と context のふたつから始めてみてください。仕様をテストするという点ではこのふたつを理解できれば十分だと個人的には思っています。it の中も Test::Unit のテストケースと同じように書いてしまっていいでしょう。</p>

<p>そのうちにテストコードを DRY にしたくなると思います。そうしたときに初めて subject や let、shared_context などの機能を使うとよいでしょう。RSpec はテストコードを DRY にするという点で非常に優秀なテスティングフレームワークです。その分、機能が多く複雑に見えるかもしれませんが、ひとつずつ使い込なしていけばいいでしょう。</p>

<p>これが私の知っている RSpec の全てというわけではありません。他にも伝えたいことはいろいろとありましたが、それをするとひとつの本になりかねないので省略させてもらいました。この記事が RSpec をもっと使いこなしたいという方の参考になれば幸いです。</p>

<h2 id="著者について">著者について</h2>

<p>赤松 祐希 (<a href="http://twitter.com/ukstudio">@ukstudio</a>)</p>

<p>フリーランスの Ruby プログラマ。最近は主に<a href="http://scaleout.jp/">株式会社スケールアウト</a>のお手伝いをさせてもらってます。あと、Ruby での TDD 入門本を現在執筆中です。落ちなければ来年ぐらいには出る気がします。みんな買ってね。</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>編注 : 以前るびまでは、<a href="../../articles/0021/0021-Rspec.html">スはスペックのス</a>という連載がありました。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>カスタムマッチャのこの使い方は個人的には気に入っていますが、この使い方だと定義が増えすぎてしまうので基本的には避けています。 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>RSpec Best Practice の Jared さんがそうです。[[0032-TranslationArticle]] <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>編注 : 遅延評価しない(正格評価される) let! というメソッドも用意されています。 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
  </body>
</html>
