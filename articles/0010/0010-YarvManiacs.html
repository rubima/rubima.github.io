<!DOCTYPE html>
<html>
  



  <head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-41117431-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-41117431-1');
  </script>
  <script src="../../js/gtag.js"></script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>YARV Maniacs 【第 5 回】 命令セット (2) リテラル・変数・定数</title>
  <meta name="description" content="">

  <script src="../../js/jquery.min.js"></script>
  <script src="../../js/bootstrap.min.js"></script>
  <link href="../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../../css/theme.css" rel="stylesheet" type="text/css">
  <link href="../../css/syntax.css" rel="stylesheet" type="text/css">
  <link href="../../css/sharebutton.css" rel="stylesheet" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="https://magazine.rubyist.net/articles/0010/0010-YarvManiacs.html">
  <link rel="alternate" type="application/rss+xml" title="Rubyist Magazine" href="https://magazine.rubyist.net/feed.xml">
  <link rel="shortcut icon" href="../../images/favicon.ico">
</head>

  <body>
    <div class="container-fluid">
        <div class="row full">
            <div class="col-md-2 hidden-xs sidebar">
                <h4>

</h4>

<h4>バックナンバー</h4>
<ul>
    
        <li><a href="../../articles/0058/0058-index.html">0058号(2018-08)</a></li>
    
        <li><a href="../../articles/prerubykaigi2018/preRubyKaigi2018-index.html">RubyKaigi 2018 直前特集号</a></li>
    
        <li><a href="../../articles/0057/0057-index.html">0057号(2018-02)</a></li>
    
        <li><a href="../../articles/prerubykaigi2017/preRubyKaigi2017-index.html">RubyKaigi 2017 直前特集号</a></li>
    
        <li><a href="../../articles/0056/0056-index.html">0056号(2017-08)</a></li>
    
        <li><a href="../../articles/0055/0055-index.html">0055号(2017-03)</a></li>
    
        <li><a href="../../articles/0054/0054-index.html">0054号(2016-08)</a></li>
    
        <li><a href="../../articles/pretokyorubykaigi11/preTokyoRubyKaigi11-index.html">東京 Ruby 会議 11 直前特集号</a></li>
    
        <li><a href="../../articles/0053/0053-index.html">0053号(2016-04)</a></li>
    
        <li><a href="../../articles/0052/0052-index.html">0052号(2015-12)</a></li>
    
        <li><a href="../../articles/0051/0051-index.html">0051号(2015-09)</a></li>
    
        <li><a href="../../articles/0050/0050-index.html">0050号(2015-05)</a></li>
    
        <li><a href="../../articles/0049/0049-index.html">0049号(2014-12)</a></li>
    
        <li><a href="../../articles/0048/0048-index.html">0048号(2014-09)</a></li>
    
        <li><a href="../../articles/0047/0047-index.html">0047号(2014-06)</a></li>
    
        <li><a href="../../articles/0046/0046-index.html">0046号(2014-04)</a></li>
    
        <li><a href="../../articles/0045/0045-index.html">0045号(2013-12)</a></li>
    
        <li><a href="../../articles/0044/0044-index.html">0044号(2013-09)</a></li>
    
        <li><a href="../../articles/0043/0043-index.html">0043号(2013-07)</a></li>
    
        <li><a href="../../articles/0042/0042-index.html">0042号(2013-05)</a></li>
    
        <li><a href="../../articles/ruby200specialen/Ruby200SpecialEn-index.html">2.0.0 Special (EN)</a></li>
    
        <li><a href="../../articles/0041/0041-index.html">0041号(2013-02)</a></li>
    
        <li><a href="../../articles/0040/0040-index.html">0040号(2012-11)</a></li>
    
        <li><a href="../../articles/0039/0039-index.html">0039号(2012-09)</a></li>
    
        <li><a href="../../articles/rubykaja/kaja.html">RubyKaja のご紹介</a></li>
    
        <li><a href="../../articles/0038/0038-index.html">0038号(2012-05)</a></li>
    
        <li><a href="../../articles/0037/0037-index.html">0037号(2012-02)</a></li>
    
        <li><a href="../../articles/0036/0036-index.html">0036号(2011-11)</a></li>
    
        <li><a href="../../articles/0035/0035-index.html">0035号(2011-09)</a></li>
    
        <li><a href="../../articles/prerubykaigi2011/preRubyKaigi2011-index.html">RubyKaigi2011直前特集号</a></li>
    
        <li><a href="../../articles/0034/0034-index.html">0034号(2011-06)</a></li>
    
        <li><a href="../../articles/0033/0033-index.html">0033号(2011-04)</a></li>
    
        <li><a href="../../articles/0032/0032-index.html">0032号(2011-01)</a></li>
    
        <li><a href="../../articles/0031/0031-index.html">0031号(2010-10)</a></li>
    
        <li><a href="../../articles/prerubykaigi2010/preRubyKaigi2010-index.html">RubyKaigi2010直前特集号</a></li>
    
        <li><a href="../../articles/0030/0030-index.html">0030号(2010-06)</a></li>
    
        <li><a href="../../articles/0029/0029-index.html">0029号(2010-03)</a></li>
    
        <li><a href="../../articles/0028/0028-index.html">0028号(2009-12)</a></li>
    
        <li><a href="../../articles/0027/0027-index.html">0027号(2009-09)</a></li>
    
        <li><a href="../../articles/0026/0026-index.html">0026号(2009-06)</a></li>
    
        <li><a href="../../articles/0025/0025-index.html">0025号(2009-02)</a></li>
    
        <li><a href="../../articles/0024/0024-index.html">0024号(2008-10)</a></li>
    
        <li><a href="../../articles/0023/0023-index.html">0023号(2008-03)</a></li>
    
        <li><a href="../../articles/0022/0022-index.html">0022号(2007-12)</a></li>
    
        <li><a href="../../articles/0021/0021-index.html">0021号(2007-09)</a></li>
    
        <li><a href="../../articles/0020/0020-index.html">0020号(2007-08)</a></li>
    
        <li><a href="../../articles/0019/0019-index.html">0019号(2007-05)</a></li>
    
        <li><a href="../../articles/0018/0018-index.html">0018号(2007-02)</a></li>
    
        <li><a href="../../articles/0017/0017-index.html">0017号(2006-11)</a></li>
    
        <li><a href="../../articles/0016/0016-index.html">0016号(2006-09)</a></li>
    
        <li><a href="../../articles/0015/0015-index.html">0015号(2006-07)</a></li>
    
        <li><a href="../../articles/rubykaigi2006/RubyKaigi2006-index.html">日本 Ruby カンファレンス 2006 特別号</a></li>
    
        <li><a href="../../articles/0014/0014-index.html">0014号(2006-05)</a></li>
    
        <li><a href="../../articles/0013/0013-index.html">0013号(2006-02)</a></li>
    
        <li><a href="../../articles/0012/0012-index.html">0012号(2005-12)</a></li>
    
        <li><a href="../../articles/0011/0011-index.html">0011号(2005-11)</a></li>
    
        <li><a href="../../articles/0010/0010-index.html">0010号(2005-10)</a></li>
    
        <li><a href="../../articles/0009/0009-index.html">0009号(2005-09)</a></li>
    
        <li><a href="../../articles/0008/0008-index.html">0008号(2005-07)</a></li>
    
        <li><a href="../../articles/0007/0007-index.html">0007号(2005-06)</a></li>
    
        <li><a href="../../articles/0006/0006-index.html">0006号(2005-05)</a></li>
    
        <li><a href="../../articles/0005/0005-index.html">0005号(2005-02)</a></li>
    
        <li><a href="../../articles/0004/0004-index.html">0004号(2004-12)</a></li>
    
        <li><a href="../../articles/0003/0003-index.html">0003号(2004-11)</a></li>
    
        <li><a href="../../articles/0002/0002-index.html">0002号(2004-10)</a></li>
    
        <li><a href="../../articles/0001/0001-index.html">0001号(2004-09)</a></li>
    
</ul>
<p class="rss-subscribe"><a href="/feed.xml">RSS</a></p>

            </div>
            <div class="col-md-10 main">
                <div class="row">
                    <div class="col-md-12">
                        <img src="../../images/rubima_logo_l.png">
                        <h1>YARV Maniacs 【第 5 回】 命令セット (2) リテラル・変数・定数</h1>
                        <div class="social-buttons">
                            <div class='sns'>            
    <ul class="clearfix">
       <li class="twitter"><a href="https://twitter.com/share?text=YARV Maniacs 【第 5 回】 命令セット (2) リテラル・変数・定数&amp;url=https://magazine.rubyist.net/articles/0010/0010-YarvManiacs.html" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa fa-twitter"></i></a></li>
       <li class="facebook"><a href="https://www.facebook.com/sharer.php?u=https://magazine.rubyist.net/articles/0010/0010-YarvManiacs.html&amp;t=YARV Maniacs 【第 5 回】 命令セット (2) リテラル・変数・定数" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa fa-facebook"></i></a></li>
       <li class="hatebu"><a href="http://b.hatena.ne.jp/add?mode=confirm&amp;url=https://magazine.rubyist.net/articles/0010/0010-YarvManiacs.html&amp;YARV Maniacs 【第 5 回】 命令セット (2) リテラル・変数・定数" target="_blank" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600');return false;"><i class="fa">B!</i></a></li>
    </ul>
</div>
                        </div>
                        
<p>書いた人：ささだ</p>

<h2 id="はじめに">はじめに</h2>

<p>YARV: Yet Another RubyVM の中を解説するこの連載。今回は前号の続きで YARV の命令セットを紹介します。</p>

<p>前号では、Ruby プログラムがどのような YARV の命令列に変換されたかを、とても簡単な例で示しました。今回も、簡単な例を続けます。</p>

<h3 id="その前に---yarv-032">その前に - YARV 0.3.2</h3>

<p>YARV をスレッドの実行に対応しました。つまり、 Thread.new{ 何か } と書くと別スレッドで「何か」が動きます。といっても、まだまだ不完全ですが。とくに I/O やシグナルまわり。そのあたりを触らないように、いじってもらえると幸いです。</p>

<p>現在の Ruby のスレッドは OS（など）が提供するネイティブスレッドを使わず、すべてユーザレベルで実現されています（俗にいうグリーンスレッドモデル）。そこで、YARV ではネイティブスレッドを使うようにしました。現在は pthread と Windows のスレッド環境に対応しています。</p>

<p>このあたりの話はいろいろあるのですが（何を隠そう、私の大学の卒論テーマはスレッドライブラリの開発です）、小難しくなるのでやめ。また、ネイティブスレッドを利用するにしても、どんな設計にするのか、選択肢とトレードオフがいろいろあります。そのあたりの話は <a href="http://www.atdot.net/~ko1/w3ml/w3ml.cgi/yarv-dev/msg/631">[yarv-dev:631] Re: thread support</a> から関連するスレッドに（試行錯誤の後として）まとまっています。興味のある方はこちらをどうぞ。</p>

<h3 id="最適化された-vm-について">最適化された VM について</h3>

<p>現在の YARV には、処理速度向上のためにいろいろな最適化の仕組みを実装しているのですが、それらはデフォルトではほとんど無効になっています。有効にして処理速度向上を実感したい方は、vm_opts.h というファイルを変更して有効にしてください。変更の仕方は、多分読めばわかると思います。今後は configure などでこの最適化の有無などを選択できるようにしたいと考えています。</p>

<p>デフォルトで最適化が無効なのは、最適化を有効にするとコンパイル速度がかなり遅くなってしまうというのが理由のひとつ。もうひとつの理由はこの連載で示している YARV 命令列と、最適化後に出力される（前回紹介した make parse で出力される）命令列が違うものになってしまうからです。</p>

<h3 id="yarv---compile-and-disassemble-cgi"><a href="http://www.atdot.net/yc">YARV - Compile and Disassemble CGI</a></h3>

<p>Ruby プログラムを YARV 命令列に変換して、それを逆アセンブルして表示する CGI を作りました（<a href="http://www.atdot.net/yc">YARV - Compile and Disassemble CGI</a>）。</p>

<p>この CGI を見てもらうと、おっきなテキストフィールドがあると思うので、そこに適当な Ruby プログラムを書き込んで、「compile and disassemble」というボタンを押してみてください。ずらずらと色々な情報、つまりこの連載でちょうど説明している YARV 命令列が表示されます。</p>

<p>もちろん、コンパイルして逆アセンブルするだけなので、YARV でそのプログラムを実行するわけじゃありません。そんな恐ろしいことは出来ません<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。</p>

<p>いろいろ試して、Ruby プログラムがこんな命令に変換されるんだ、というのを見て楽しんでもらえればいいと思います。</p>

<p>ちなみに、もうひとつあるボタン「compile and disassemble (to optimized instructions)」は、コンパイル時に YARV 命令列を最適化して表示します。多分、見てもさっぱりわかんないんじゃないかと思います。この最適化された命令列の読み方は、いずれ紹介したいと思っています。</p>

<h3 id="今回のテーマ命令列-2-リテラル変数定数">今回のテーマ：命令列 (2) リテラル・変数・定数</h3>

<p>さて、前置きが長くなりましたが、今回は「リテラル・変数・定数」式を表現する YARV 命令列についての解説です。なぜ、このテーマを選んだかというと、とても簡単だからです。</p>

<p>具体的には、</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">1</code></pre></figure>

<p>とか、</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">/abc/</code></pre></figure>

<p>とか、</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@a = 1</code></pre></figure>

<p>とか、そういうのを、YARV 命令列ではどうやって表現するのか解説します。見るからに簡単そうですね。</p>

<h2 id="リテラル式">リテラル式</h2>

<p>Ruby でリテラルというと、true/false/nil などの固定の値、数値（1、12345678901234567890 、1.2）、シンボル（:Symbol）、文字列（”String”）、正規表現（/abc/）などがあります。また、似たようなものに配列（[1, 2, 3]）、ハッシュ（{1=&gt; “a”, 2=&gt; “b”}）、範囲（1..3）などの式があります。</p>

<p>YARV 命令列では、これらのリテラル式はスタックにそのリテラルが示すオブジェクトを積む、という操作になります。</p>

<h3 id="immutable-なオブジェクト">immutable なオブジェクト</h3>

<p>変更できないオブジェクトを immutable なオブジェクトと言います<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>。たとえば、true オブジェクトはいつも true です。123 はいつも 123 です。内容が変わったりはしません。前述した例では、true/false/nil などの固定の値、数値（1、12345678901234567890 、1.2）、シンボル（:Symbol）、正規表現（/abc/）などがこれにあたります。</p>

<p>これらのリテラル式は <strong>putobject</strong> という命令で表現されます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">a = true
a = false
a = 123
a = :Symbol
a = /abc/
nil</code></pre></figure>

<p>という Ruby プログラムは次のようにコンパイルされます。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0000 putobject       true
0002 setlocal        2
0004 putobject       false
0006 setlocal        2
0008 putobject       123
0010 setlocal        2
0012 putobject       :Symbol
0014 setlocal        2
0016 putobject       /abc/
0018 setlocal        2
0020 putnil
0021 end</code></pre></figure>

<p><strong>setlocal</strong> というのは、「ローカル変数 a （命令列中では 2 と表現されている）に、そのリテラルの値を代入する」、という意味です。これについては簡単そうで難しいので次回説明します。<strong>end</strong> は前号でも紹介したとおり、そのスコープの終わり（そして呼び出し元、例えばメソッドコールの返り値としてスタックトップの値を返す）、という意味ですが、これもあわせて次回に。</p>

<p>setlocal、end を除くと、上記命令列には「putobject [何か]」という命令と、putnil という命令だけになります。putobject は、[何か] をスタックに積む、という意味で、putnil は nil をスタックに積む、という意味になります。putobject nil と書いてもまったく同様なのですが、putobject nil のパターンは大量に出てきて、コンパイラを書くときに面倒くさかったので一個命令を追加しました（今思えば、マクロにすればよかった）。</p>

<p>これは簡単ですね。</p>

<p>余談ですが、</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">true
false
123
:sym
/abc/
nil</code></pre></figure>

<p>という何もしない Ruby プログラムをパースするとどうなるでしょう。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0000 putnil
0001 end</code></pre></figure>

<p>何もしない YARV 命令列が生成されました<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>。</p>

<h3 id="文字列リテラル">文字列リテラル</h3>

<p>次は文字列リテラルです。文字列リテラルは破壊的な変更が可能なので mutable なオブジェクトと言えます。たとえば、プログラム上同じ位置にあっても、文字列リテラルが返すオブジェクトは毎回異なります<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>。</p>

<p>というわけで、毎回同じオブジェクトをスタックトップに置くだけの putobject 命令は使えないので、代わりに <strong>putstring</strong> 命令を使います。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">a = 'abc'
nil</code></pre></figure>

<p>というプログラムは、</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0000 putstring       "abc"
0002 setlocal        2
0004 putnil
0005 end</code></pre></figure>

<p>とコンパイルされます。面倒なので、これからは setlocal 以下は載せないようにしますね。</p>

<p>とくに難しいことはありません。</p>

<h3 id="配列式ハッシュ式">配列式・ハッシュ式</h3>

<p>配列やハッシュ式、範囲式で生成されるオブジェクトも mutable です。これらの式の特徴は、先ほどの例とは違って、他のオブジェクトを利用して作ることです。たとえば、配列オブジェクトを生成する [1, 2, 3] という式は、Fixnum のオブジェクト 1, 2, 3 を利用して作ります。</p>

<p>これらはどのようにするかというと……、例を見たほうが早いですね。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">["a", "b", "c"]</code></pre></figure>

<p>をコンパイルすると、</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0000 putstring        "a"
0002 putstring        "b"
0004 putstring        "c"
0006 newarray         3   # スタックトップ 3 つをとってきて
                          # ひとつの配列にする</code></pre></figure>

<p>という命令列になります。つまり、スタックに “a”、”b”、”c” と積んで、最後に <strong>newarray</strong> 命令でスタックトップの 3 つ、つまり今積んだ “a”、”b”、”c” を取ってきて配列にする、という意味です。</p>

<p>では、要素が String ではなくて Fixnum である配列を見てみましょう。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[1, 2, 3]</code></pre></figure>

<p>このような Ruby プログラムを YARV 命令列にすると、次のようになります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0000 duparray        [1, 2, 3]</code></pre></figure>

<p>要素がすべてリテラル（putobject 命令で済むもの）だった場合、毎回各要素をスタックに積まなくても作るものが決まっているため、<strong>duparray</strong> 命令ひとつ（配列オブジェクトを dup してスタックトップに積む）で済むことになります。</p>

<p>ハッシュは配列の要素数を 2 倍（1 要素 key と value で 2 つ）にしただけです。<strong>newhash</strong> 命令になります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{1 =&gt; "a", 2 =&gt; "b", 3 =&gt; "c"}</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0000 putobject       1
0002 putstring       "a"
0004 putobject       2
0006 putstring       "b"
0008 putobject       3
0010 putstring       "c"
0012 newhash         6   # 3 要素なのでスタックトップから
                         # 6 オブジェクト取ってくる</code></pre></figure>

<h3 id="範囲式">範囲式</h3>

<p>範囲式は Range オブジェクトを生成します。これを行うための命令 <strong>newrange</strong> は先端と終端を示すオブジェクト 2 つをスタックトップから取り出し、新しい Range オブジェクトを生成します。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[('a'..'b'), ('a'...'b')]</code></pre></figure>

<p>というプログラムは、</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0000 putstring       "a"
0002 putstring       "b"
0004 newrange        0
0006 putstring       "a"
0008 putstring       "b"
0010 newrange        1
0012 newarray        2</code></pre></figure>

<p>このような YARV 命令列になります。(x..y) の場合は newrange の命令オペランドに 0 を、(x…y) の場合は 1 を指定してあります。</p>

<p>さて、ここで</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">(1..10)</code></pre></figure>

<p>という、よくありがちな Range 式をコンパイルしてみましょう。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0000 putobject       1..10</code></pre></figure>

<p>newrange 命令はありません。これは、Range オブジェクトは（多分） immutable なので、範囲を指定する式が二つとも immutable である場合はこのような最適化が可能なのです。</p>

<h2 id="変数">変数</h2>

<p>ここでは変数について説明します。ただ、ローカル変数は面倒くさいので次号にまわします。</p>

<h3 id="インスタンス変数">インスタンス変数</h3>

<p>YARV 命令として、インスタンス変数を設定したり、値を取得するための特別な命令を用意しています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@a = 1
a = @a</code></pre></figure>

<p>は次のような YARV 命令列になります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0000 putobject            1
0002 setinstancevariable  :@a
0004 getinstancevariable  :@a</code></pre></figure>

<p><strong>set/getinstancevariable</strong> という命令があるだけです。とても簡単。</p>

<h3 id="グローバル変数">グローバル変数</h3>

<p>YARV 命令として、グローバル変数を設定したり、値を取得するための特別な命令を用意しています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$global = 1
a = $global</code></pre></figure>

<p>は次のような YARV 命令列になります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0000 putobject        1
0002 setglobal        $global
0004 getglobal        $global
0006 setlocal         2</code></pre></figure>

<p><strong>set/getglobal</strong> という命令があるだけです。とても簡単。</p>

<h3 id="クラス変数">クラス変数</h3>

<p>YARV 命令として、クラス変数を設定したり、値を取得するための特別な命令を用意しています。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@@a = 1
a = @@a</code></pre></figure>

<p>は次のような YARV 命令列になります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0000 putobject         1
0002 setclassvariable  :@@a, true
0005 getclassvariable  :@@a</code></pre></figure>

<p><strong>set/getclassvariable</strong> という命令があるだけです。setclassvariable には true という命令オペランドが付いてますね。これはなんでしょうか[^5]。えーと、調べてみると警告を出すためにクラス変数定義の場所で true / false が変わったりするようなのですが、今 ruby 1.9 のソース（つまり、YARV のソース）を確認すると、この値を見てませんねぇ（汗）　リファクタリング対象のようです。</p>

<h2 id="定数">定数</h2>

<p>Ruby の定数は不思議なことに、他の言語でいう定数ではありません。リフレクション機能を使ったり、警告を無視したりすれば簡単に再定義が可能です。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">C = 1
C = 2
#=&gt; test.rb:2: warning: already initialized constant C
# 警告は出るが、再定義される。</code></pre></figure>

<p>また、実行時に後述する定数検索を行わなければならないため、定数のくせにアクセスコストは定数ではありません（検索コストは検索パスの大きさに比例します）。そのため、一度検索したらその結果をキャッシュしておく__インラインキャッシュ__も用意していますが、それも後述します。</p>

<h3 id="定数アクセス命令">定数アクセス命令</h3>

<p>定数アクセスには次のように、いくつか種類があります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">C    # その実行コンテキストで探す C
::C  # トップレベルで定義してある C
C::D # C をその実行コンテキストで探し、そのクラス / モジュール
       から D を検索</code></pre></figure>

<p>そのため、ただ C としてアクセスしているのか、::C としてアクセスしているのかで、意味が全然違います。そこで、定数の値を得る（スタックに積む）命令 <strong>getconstant</strong> はスタックオペランドに定数検索の起点を置くことにしました。</p>

<dl>
  <dt>起点が nil だったら</dt>
  <dd>現在の実行コンテキストで検索</dd>
  <dt>起点がクラス・モジュールオブジェクトだったら</dt>
  <dd>そのクラス・モジュールオブジェクトを起点に検索</dd>
</dl>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># C
putnil
getconstant  :C
# ::C
putobject Object
getconstant  :C # Object の中の C （つまりトップレベル）を探る
# C::D
putnil
getconstant  :C # 現在の実行コンテキストで C を探る
getconstant  :D # C の中の D を探る</code></pre></figure>

<p>定数を設定する <strong>setconstant</strong> 命令も同様に、スタックオペランドで設定する場所を決めます。</p>

<p>ちょっとあいまいな言葉が多かったりしますが、厳密に言い出すととても面倒なのでこの辺で。</p>

<h3 id="定数検索">定数検索</h3>

<p>定数の検索は、処理系実装者から見るとかなり作るのが面倒な部分になっています。ふつう気がつかないんだけど、細かい仕様がたくさんあるんです。詳細は RHG を読んでください（<a href="http://i.loveruby.net/ja/rhg/variable.html">第 6 章 変数と定数</a>、<a href="http://i.loveruby.net/ja/rhg/module.html">第 14 章 コンテキスト</a>）。要は、コンパイル時には定数検索パスが決まらないのです。</p>

<p>この話題は、実行コンテキストの話も含めて、より細かい実装の段階で解説します。</p>

<h3 id="定数キャッシュ">定数キャッシュ</h3>

<p>さて、定数は定数という名前なのですから、再定義できるとはいっても、めったにそんなことは起こりません。そこで、一度値を検索したらキャッシュすることにしました。それを実現するのが <strong>get/setinlinecache</strong> 命令です。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">cache_start:                  # ラベル
  getinlinecache cache_end
   [... 何か式 ...]
   setinlinecache cache_start
cache_end:                    # ラベル</code></pre></figure>

<p>getinlinecahce 命令は、まず自分自身が値をキャッシュしているかどうか確認しています。もしキャッシュしており、その値が使えたら位置 cache_end（setinlinecache 命令の後ろ）へジャンプします。そうでなければ、まず nil を積んでから[^6] [… 何か式 …] の部分を実行します。setinlinecache 命令は、位置 cache_start で示される getinlinecache 命令のキャッシュ領域（命令オペランド部分）に、[… 何か式 …] の計算結果をキャッシュします。</p>

<p>キャッシュした値が正しいかどうかは、定数を定義をすると増加するカウンタ値（これは VM グローバルなカウンタ）とともにキャッシュしておき、現在のそのカウンタ値とキャッシュしたときのカウンタ値を比べることでその値が使えるかどうか確認できます。</p>

<p>この命令は Ruby プログラムの意味の表現とは直接関係ありませんが、性能には結構影響します。</p>

<p>さて、これを踏まえて、次に示す定数アクセスプログラムの YARV 命令列へのコンパイル結果を見てみましょう。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[C, ::C, C::D]</code></pre></figure>

<p>次のようになります。</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0000 getinlinecache  &lt;ic&gt;, 7    # &lt;ic&gt; については後述
0003 getconstant     :C
0005 setinlinecache  0
0007 getinlinecache  &lt;ic&gt;, 17
0010 pop                        # pop については後述
0011 putobject       Object
0013 getconstant     :C
0015 setinlinecache  7
0017 getinlinecache  &lt;ic&gt;, 28
0020 pop
0021 putnil
0022 getconstant     :C
0024 getconstant     :D
0026 setinlinecache  17
0028 newarray        3
0030 end</code></pre></figure>

<p><strong>pop</strong> 命令はスタックからひとつ値を捨てる命令です。getinlinecache の命令オペランド &lt;ic&gt; は値をキャッシュする領域を示しています。</p>

<p>ちょっと長いですが、意味はそれぞれ単純なのでよく見ればわかると思います。</p>

<h2 id="おわりに">おわりに</h2>

<p>今回も YARV 命令セットの説明を行いました。リテラル・変数・定数という、Ruby でも簡単なところばかりだったので、退屈してしまったかもしれません。次回は、命令セットの続きとして、もうちょっと難しいところに踏み込んでみようと思います。お楽しみに。</p>

<h2 id="著者について">著者について</h2>

<p>ささだこういち。学生。</p>

<p>いつもこの時期になると英語に対する危機感を覚えるんだけど、すぐにのど元を過ぎてしまう。まぁいいか（いや、良くないよ！）。</p>

<h2 id="yarv-maniacs-連載一覧">YARV Maniacs 連載一覧</h2>

<ul>
  <li>
    <p><a href="../../articles/0053/0053-YarvManiacs.html">YARV Maniacs 【第 13 回】 事前コンパイルへの道</a></p>
  </li>
  <li>
    <p><a href="../../articles/0041/0041-YarvManiacs.html">YARV Maniacs 【第 11 回】 最近の YARV の事情</a></p>
  </li>
  <li>
    <p><a href="../../articles/0033/0033-YarvManiacs.html">YARV Maniacs 【第 10 回】 例外処理（初級編）</a></p>
  </li>
  <li>
    <p><a href="../../articles/0017/0017-YarvManiacs.html">YARV Maniacs 【第 9 回】 特化命令</a></p>
  </li>
  <li>
    <p><a href="../../articles/0015/0015-YarvManiacs.html">YARV Maniacs 【第 8 回】 命令列のシリアライズ</a></p>
  </li>
  <li>
    <p><a href="../../articles/0013/0013-YarvManiacs.html">YARV Maniacs 【第 7 回】 YARV 命令セット (4) 分岐</a></p>
  </li>
  <li>
    <p><a href="../../articles/0012/0012-YarvManiacs.html">YARV Maniacs 【第 6 回】 YARV 命令セット (3) メソッドディスパッチ</a></p>
  </li>
  <li>
    <p><a href="../../articles/0010/0010-YarvManiacs.html">YARV Maniacs 【第 5 回】 命令セット (2) リテラル・変数・定数</a></p>
  </li>
  <li>
    <p><a href="../../articles/0009/0009-YarvManiacs.html">YARV Maniacs 【第 4 回】 命令セット (1) YARV 命令セットの初歩の初歩</a></p>
  </li>
  <li>
    <p><a href="../../articles/0008/0008-YarvManiacs.html">YARV Maniacs 【第 3 回】 命令ディスパッチの高速化</a></p>
  </li>
  <li>
    <p><a href="../../articles/0007/0007-YarvManiacs.html">YARV Maniacs 【第 2 回】 VM ってなんだろう</a></p>
  </li>
  <li>
    <p><a href="../../articles/0006/0006-YarvManiacs.html">YARV Maniacs 【第 1 回】 『Ruby ソースコード完全解説』不完全解説</a></p>
  </li>
</ul>

<hr />

<p>loop{
   p “String”.object_id # mutable / 毎回オブジェクト ID が変わる
   p true.object_id     # immutable / オブジェクト ID は不変
   p :Symbol.object_id  # immutable / オブジェクト ID は不変
 }
というプログラムを動かすとわかります。
[^5]: 本稿執筆中、筆者はマジで忘れていた。
[^6]: nil を積むのは、getconstant 命令の出現箇所の多くで次の命令が putnil 命令であることが多いため。</p>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>バグが多すぎる、ということがばれるのが怖い、というわけじゃなくて、セキュリティの問題です。もちろん。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>ただし、Ruby では特異メソッドやインスタンス変数を付け加えることができるので、厳密な意味で immutable とは言えません。ここでの判断基準は現在のインタプリタの挙動によります。 <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>もうひとつちなむと、この 2 命令の YARV 命令列は何も無いメソッドをコンパイルしても生成されます。 <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>異なるオブジェクト、というのはオブジェクトID（obj.object_id で取れる値）が異なるオブジェクト、という意味です。immutable なオブジェクトでは、プログラムの同じ場所では、毎回同じオブジェクトID を持つオブジェクトが生成されますが、文字列オブジェクトはそうではありません。簡単な実験としては、 <a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
  </body>
</html>
