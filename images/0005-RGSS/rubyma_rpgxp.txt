Rubyistが知りたいかもしれないRGSSの世界

2005.1.10 サイロス誠

０．はじめに。

　エンターブレインから発売された「RPGツクールXP（以降、"ツクールXP"）」には、Rubyの拡張版「RGSS」が搭載されています。これによってゲームのシステムをRubyスクリプトで構築することが可能になっています。
　でも、このRGSS、オープンソースではないですし、RPGツクールXPのサイトからダウンロードできる体験版では、閲覧できるRGSSの詳細がほとんど分からないという状態ですし（かろうじて、RGSSがRubyに似ていると言うことはわかりますが・・・）、ヘルプも利用できないため、ツクールXPの製品版を所持していない状態で入手できる情報は非常に限られたものとなっています。
　そこで、本コラムでは、意外と中身について知られていないRGSSで一体何ができるのか、そこらへんをツラツラと書いてみようと思います。
　なるべく分かり易いように記述するつもりですが、至らないところが多数有るかとは思います。そのときはなにぶんご容赦を・・・。

１．「RGSS」が登場した背景

　2004年の7月に、エンターブレインから「RPGツクールXP」というソフトが発売されました。
　「RPGツクールシリーズ」は1980年代からＲＰＧコンストラクションツール（なんとPC-8801シリーズから！懐かしい！）として発売されていましたが、この「ツクールXP」では、他のシリーズには無かった大きな特徴として、「RGSS」の搭載が挙げられます。
　
２．RGSSって何？

　「RGSS」は「Ruby Game Scripting System」の略で、拡張版Rubyを使ってゲームシステムを用意しようというものです。これまでの「RPGツクール」シリーズでは困難だった「ゲームシステムそのものの改変」が、RGSSで使えるスクリプトを使うことで簡単になったことが大きいポイントです。

　たとえば、「ツクールXP」では、マップ作成やイベント編集、敵キャラクター情報作成等が出来るのですが、これらの成果物を利用してゲームを実行するのは全てRGSSスクリプト上で行います。プロジェクトを新規作成すると、デフォルトでの状態のRGSSスクリプトを「ツクールXP」内蔵のスクリプトエディタを使用して確認できますが、そこでマップのスクロールや戦闘時のダメージ計算もRGSSで行っていることが確認できます。
　ということは、そこに書かれてあるスクリプトを改変して、思い通りのシステムに修正できるということになります。これはウレシイですねぇ。また、グラフィックやサウンドなどの煩雑な手続きを踏む必要がある箇所は、RGSS内部で処理してくれて、しかも比較的容易に記述できるように暮らす設計がなされていますので、細かいグラフィック処理などを考えることなくロジック記述に専念しやすくなるというのは非常にウレシイことです。
　また、「今、新しいゲーム考えているんだけど、デフォルトで用意してくれるスクリプトだと無駄が多いなぁ」と思ったら、一から全て書き直すということも可能です。必要最低限の約束事を守れば、自分好みのコーディングでゲームシステムを作成できます。
　ということは、やろうと思えば、シューティングやアクションなんかも作れます。RGSSが搭載されていない従来のツクールを作った別ジャンルのゲームを作った、という作品もありますので（たとえば、「ツクールXP」サンプルゲームの「ししむら」はアクションRPGとなっています）、購入されている方は参考にしてみるといいでしょう。

　これだけ自由度の高いゲーム製作が可能になると分かると、RGSSそのもののシステムに興味が沸かれるかと思います（沸かない？　沸いてくださいよぉ）。次では、そのRGSSで何が出来るか、そこらへんを説明したいと思います。

３．RGSSになってできること

　さて、RGSS でできることといえば・・・

　・Rubyでできること

　・・・い、いや、ヲレは正気ですよ。でもこれは凄いことですよ。
　最初、RGSSが「Rubyをベースにしたスクリプト言語システム」ということで、「Rubyのサブセットちゃうかなぁ〜」と考えていたのですが、ところがどっこい、実際触ってみると、Rubyで出来ることは大抵出来てしまうではありませんか。また、バッククォートも使えてしまいます・・・あまり有用ではありませんが（笑）。

　また「ツクールXP」のヘルプにはRGSSのRuby部分の解説もあるのですが、いくつか便利なメソッドが省略されています（例：Stringクラスのsplitメソッド）。でも、ただ単にヘルプに明記されていないだけで（Rubyというか、スクリプト言語に慣れていない人のための配慮？）、実際は使うことが出来ます。ヘルプにないからと言って、メソッドが使えないことは無いようです。

　あ、外部ライブラリ（dateクラスなど）は添付されていないので使えませんが、"require"は普通に使えますので、自分で作った外部ライブラリを使うことは可能です（ただし、Cで組まれた拡張ライブラリは未確認です・・・「RPGツクール」自体はVisualC++で作られているということで、VisualC++で作られた拡張ライブラリは動くのでは・・・と予感しています。いつかはやってみようと考えているのですが・・・）

　更に、Rubyから追加されている項目は以下の５点です。

　１．グラフィックの表示・管理（スプライトの実装、画像データのキャッシュ、画面の更新等）
　２．音楽の演奏・管理（音楽の演奏・停止等）
　３．入力情報の取得（キーボードやゲームパッド等のボタン押下状態など）
　４．「RPGツクールXP」のエディタで作成したデータとのインタフェース（「ツクールXP」側で作ったデータを読み込んでオブジェクトして扱うことが出来る）
　５．Tableクラス（Cによる拡張クラスで、中身はint型の配列）
　
　普段は拡張ライブラリをCやC++でいちいち書かなくても良く、簡単に思い通りのグラフィックを表示できるは非常に気持ちが良いものです。
　
　ここまで書いて、「はい、これで終わりです」とか言ってしまうと怒られるので、次章から実際にスクリプトを組んで説明しま・・・と言いたいところですが、その前に準備が必要ですので、そこのところから説明しましょう。

４．RGSSを組む前に

　ここでは、RGSSでスクリプトを組む前準備を説明していきましょう。

　まず、「ツクールXP」以下の何にも無い画面が出てきます（図<rpgxp000.png>挿入）。
（その前に、最初に起動したときはオンラインアクティベーションとかなんとかがあるのですが、ここでは割愛します）
　
　その状態で、メニューの「ファイル」−「プロジェクトの新規作成」を選ぶと、デフォルトのデータを格納するために、新たに作成するディレクトリ名（＝プロジェクト名）を求めるダイアログが登場します（図挿入）。そこにこれから作成するゲームに合ったプロジェクト名を入力して「OK」ボタンを押します。
　
　この時点でマップチップなどが現れますが、まだ「素のデータ」状態で、グラフィックも「RPGツクールXP」が用意しているデフォルトのもの、更に他のデータや情報も未設定です。ここから、自作のグラフィックやアイテムや呪文などの情報、シナリオ上必要なイベントなどを設定・追加していきます。
　
　さて、キモのスクリプトですが、ツールチップ（図<rpgxp001.png>挿入）か、メニューの「ツール」−「スクリプトエディタ」を選ぶとスクリプトの編集画面になります（図<rpgxp002.png>挿入）。画面の右側がスクリプトエディタで、左側がセクションリスト（スクリプト内容の表題）です。
　
　ここまで来たら、早速スクリプトを解析＆編集といきたいところですが・・・。ここでちょっとストップ。
　
　実際ソースを解析してみると分かるのですが、このデフォルト状態では、ゲームの動作や画面まわり、イベントの詳細（イベントエディタで選べるイベントも、実装はRGSSです！）などがこのRGSSで実装されています。しかも、RGSSは「RPGツクールXP」で設定したデータに依存しているわけではありませんので、使おうと思ったら使う程度の感覚でゲームを作成することが可能と言うことが分かります。
　
　確かに、デフォルトのスクリプトを修正して、プログラムの動作をチェックする方法もありますが、デフォルトがかなりタイミング取りとかなんとかで複雑になってまして・・・それらを一つずつ解析するよりかは、最低限の動作原理を理解して、それから解析を始めたほうがより理解が早そうと考えたので、イチからスクリプトを組んでみましょう。
　
　それでは、デフォルトのスクリプトを全部削除してしまいましょう。
　削除するときは、セクションごと消していく方法が便利です。セクションごと削除するときは、セクションリストでセクション名をクリックして、DELキーを押すとセクションごと消去できます（ただし、最低限一つのセクションは残るので、最後の一つはスクリプトエディタで全てのスクリプトを消去します）。
　
　完全にスクリプトを消去した状態が（図<rpgxp003.png>挿入）です。Mainセクションにスクリプトを追加する形で説明します。
　
　次の章では、簡単なスクリプトをもとに、RGSSに必要な構造について説明してみましょう。
　
４．RGSSの基本的な構造

　それでは、Mainセクションに以下のスクリプトを記述してみます。
　
　＝＝（スクリプトここから）＝＝
　
  1 | class Util
  2 |   @@dx = [0, 0, -1, 1, 0]
  3 |   @@dy = [0, 1, 0, 0, -1]
  4 |   
  5 |   def Util.a2d(dir)
  6 |     dp = dir >> 1
  7 |     [@@dx[dp], @@dy[dp]]
  8 |   end
  9 | end
 10 | 
 11 | class Spr
 12 |   def initialize(name, vp)
 13 |     @final = false
 14 |     @sp = Sprite.new(vp)
 15 |     @sp.bitmap = Bitmap.new(name)
 16 |     @sp.x = 0
 17 |     @sp.y = 0
 18 |     @sp.visible = true
 19 |     @stride = 8
 20 |   end
 21 |   
 22 |   def adjustment(n, min, max, size)
 23 |     if n < min
 24 |       min
 25 |     elsif n + size > max
 26 |       max - size
 27 |     else
 28 |       n
 29 |     end
 30 |   end
 31 |   
 32 |   def update
 33 |     br = @sp.bitmap.rect
 34 |     sr = @sp.viewport().rect
 35 | 
 36 |     d = Input.dir4
 37 |     dx, dy = Util.a2d(d)
 38 | 
 39 |     @sp.x = adjustment(@sp.x + dx * @stride, sr.x, sr.width, br.width)
 40 |     @sp.y = adjustment(@sp.y + dy * @stride, sr.y, sr.height, br.height)
 41 |     
 42 |     @final = Input.trigger?(Input::B)
 43 |   end
 44 |   
 45 |   def final?
 46 |     @final
 47 |   end
 48 | end
 49 | 
 50 | def_viewport = Viewport.new(0, 0, 640, 480) # 引数は、（左上x座標、左上y座標、幅、高さ）の順
 51 | sp = Spr.new("ruby.png", def_viewport)
 52 | loop{
 53 |   Graphics.update()
 54 |   Input.update()
 55 |   sp.update()
 56 |   if sp.final?()
 57 |     break
 58 |   end
 59 | }
　
　＝＝（スクリプトここまで）＝＝
　
　このスクリプトを実行してみると、「ruby.png」にセーブした画像がキーパッドを押した方向に移動します（図<rpgxp004.png>挿入）。また、画面の端っこまで移動するとそこで止まるようになっています。
　
　上記スクリプトの基本的な流れは以下の通りです。これらの処理に対応したスクリプトの行を併記しておきます。
　
　（１）クラス定義（1〜48行目）
　　　　↓
　（２）データ初期化（50〜51行目）
　　　　↓
　（３）グラフィックまわりの更新（ Graphics.update メソッドを呼び出す）（53行目）
　　　　↓
　（４）入力まわりの更新（ Input.update メソッドを呼び出す）（54行目）
　　　　↓
　（５）ユーザ定義の操作（ロジック部処理やグラフィック操作、タイミング同期など）（55行目）
　　　　↓
　（６）（３）へ戻ってあとは繰り返し（なんらかのタイミングでループを抜ける（56〜58行目））
　
　最低限これらの流れを把握しておけば、あとは（５）の部分に専念すれば問題は無いと思います。
　
　プログラム自体はそんなにトリッキーなことはしておりませんので、rubyistの皆さんならスクリプトを読めば大体の感触は掴めると思います。ので、必要最低限の説明にとどめて、詳しい解説は割愛いたします（笑）。
　
　１：14行目の「Sprite」クラス。クラスに関連づけたビットマップオブジェクト（これも Bitmap クラスのインスタンス）をスプライト表示するためのクラスです。x,yプロパティで表示する位置を設定して、visibleプロパティで表示のON/OFFを設定します。表示を行うのは、必ず Sprite クラスを通じて行います。
　
　２：15行目の「Bitmap」クラス。ビットマップデータを管理するクラスで、画像の取り込みだけではなく、ビットマップの複写、文字の描画なども行えます。ビットマップの大きさは rect プロパティで取得できます。
　
　３：36行目の「Input.dir4」メソッド。キーパッドの方向ボタンを押しているときは、それに応じた数値を返却します。但し、その値が 2(下),4(左),6(右),8(上) となっていますので、1〜9行目のような処理を一度噛ませてから移動時の座標を求めています。
　
　４：50行目の「Viewport」クラス。スプライトの表示範囲を設定します。たとえば、「RPGツクールXP」の場合、ゲーム画面の大きさは 640x480 ですので、画面一杯を表示範囲にしたいときは(0,0,640,480)の大きさでViewportクラスのインスタンスを作成します。また、画面の左上、4分の1を表示範囲にしたければ、(0,0,320,240)の大きさで作成すればその範囲だけでスプライトを表示できますし、右下4分の1を範囲にするときは(320,240,320,240)でインスタンスを作成すればいいわけです。
　
５．まとめ

　ここまで、RGSSについて簡単に説明致して参りましたが、いかがでしたか？
　基本的には、８０年代に沢山出ていた「BASICで簡単ゲームプログラミング」のようなノリでプログラムを初めて、デフォルトのスクリプトを参考に、次第に機能を拡張していって慣れていけば、有る程度のゲームは作れるのではないかと思います。
　
　また、今回は説明致しませんでしたが、「RPGツクールXP」本体で設定・登録しておいたデータ（グラフィック・サウンド・各種パラメータ）をRGSSで簡単に呼び出せるようになっていますので、グラフィックデータなどを本体で管理しておけばRGSS上で面倒なデータ管理に悩まされずに済みますので、ガシガシ使ってみることをお奨めします。
　
　これらの便利な機能を駆使していけば、行く末には、皆があっと驚くゲームを開発できるのは夢ではないと考えています（実際、これらのスクリプトを駆使して、非常に効果的な演出やシステムのゲームも「RPGツクールXP」のサンプルゲームとして収録されています）。
　
　それでは、この文章が「RGSS」もしくは「RPツクールXP」ユーザ数増加の一翼を担えることを願って、本記事を締めたいと思います。

６．最後に自己紹介なぞ

　京都の南端でプログラムを書いている（でも住んでいるのは大阪）サイロス誠と申します。数年前にRubyに出会って、そのおもしろさにハマって以来、スクリプト言語で出来ることは大抵Rubyでこなしています（やや誇張アリ）。
　また、ゲーム作成についても興味があり、幾つかゲームコンストラクションツール（勿論、「RPGツクール」シリーズも含まれています）を試してみたのですが、プリセットの機能を選択して貼り付けるタイプのモノがほとんどでしたので、ゲームシステムを改変できるくらい自由度の高いツールは中々ありませんでした（昔のツールでは金額の単位を「G」以外変更できない等といった制限がありました。どうやって日本風RPGを作ればいいのか・・・）。
　そんなある日、「RPGツクール」最新版の「RPGツクールXP」の発売が発表され、そこにRGSSが搭載されることを知ったわけです。早速購入していろいろ弄ってみたところ、直感的に分かり易いRubyのゲーム作成環境としても使えることがわかり、それが今回の記事に繋がったわけです。
